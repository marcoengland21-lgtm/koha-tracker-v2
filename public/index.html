<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Koha">
  <meta name="theme-color" content="#020617">
  <meta name="description" content="Track koha and expenses for tangihanga">
  <link rel="apple-touch-icon" href="icon-180.png">
  <link rel="manifest" href="manifest.json">
  <title>Meaalofa ‚Ä¢ Koha Tracker</title>
  <!-- Google Cloud Vision API used for OCR (server-side) -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    * { -webkit-tap-highlight-color: transparent; }
    body { background: #020617; margin: 0; padding: env(safe-area-inset-top) 0 env(safe-area-inset-bottom); font-family: system-ui, -apple-system, sans-serif; }
    ::-webkit-scrollbar { display: none; }
    input[type="number"]::-webkit-inner-spin-button,
    input[type="number"]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
    input[type="number"] { -moz-appearance: textfield; }
    .spin { animation: spin 1s linear infinite; }
    @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    .pulse { animation: pulse 2s ease-in-out infinite; }
    @keyframes slideIn { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
    .slide-in { animation: slideIn 0.2s ease-out; }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    .fade-in { animation: fadeIn 0.2s ease-out; }
    @keyframes progressBar { 0% { background-position: 0% 50%; } 100% { background-position: 100% 50%; } }
    @keyframes scan { 0% { top: 0; } 50% { top: 100%; } 100% { top: 0; } }
    @keyframes loading { 0% { width: 20%; } 50% { width: 80%; } 100% { width: 20%; } }
    .progress-animated { 
      background: linear-gradient(90deg, #06b6d4, #8b5cf6, #ec4899, #06b6d4);
      background-size: 300% 100%;
      animation: progressBar 2s linear infinite;
    }
    @keyframes scanPulse {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.05); opacity: 0.8; }
    }
    .scan-pulse { animation: scanPulse 1.5s ease-in-out infinite; }
    @keyframes shimmer {
      0% { background-position: -200% 0; }
      100% { background-position: 200% 0; }
    }
    .shimmer {
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
      background-size: 200% 100%;
      animation: shimmer 1.5s infinite;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useMemo, useCallback, useRef } = React;

    // Storage helper
    const S = {
      get: (k, d) => { try { return JSON.parse(localStorage.getItem('koha_' + k)) || d } catch { return d } },
      set: (k, v) => { try { localStorage.setItem('koha_' + k, JSON.stringify(v)) } catch {} }
    };

    // FIX #1: Unified scan session storage (replaces scattered localStorage keys)
    const ScanSession = {
      KEY: 'koha_scan_session',
      save: (data) => {
        const session = { ...data, savedAt: Date.now() };
        try {
          const json = JSON.stringify(session);
          localStorage.setItem(ScanSession.KEY, json);
          sessionStorage.setItem(ScanSession.KEY, json);
          console.log('ScanSession saved:', Math.round(json.length/1024), 'KB');
        } catch (e) {
          console.error('ScanSession save failed:', e);
          // Try sessionStorage only if localStorage fails
          try { sessionStorage.setItem(ScanSession.KEY, JSON.stringify(session)); } catch {}
        }
      },
      get: () => {
        try {
          const data = localStorage.getItem(ScanSession.KEY) || sessionStorage.getItem(ScanSession.KEY);
          if (!data) return null;
          const session = JSON.parse(data);
          // Expire after 5 minutes
          if (Date.now() - session.savedAt > 300000) {
            ScanSession.clear();
            return null;
          }
          return session;
        } catch { return null; }
      },
      clear: () => {
        try {
          localStorage.removeItem(ScanSession.KEY);
          sessionStorage.removeItem(ScanSession.KEY);
          // Also clear old keys for cleanup
          ['pending_scan_image', 'pending_scan_time', 'pending_scan_result'].forEach(k => {
            localStorage.removeItem(k);
            sessionStorage.removeItem(k);
          });
        } catch {}
      }
    };

    // FIX #2: Better image compression that guarantees fitting in storage
    const compressForStorage = (base64, targetKB = 400) => {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement('canvas');
          let width = img.width;
          let height = img.height;
          let quality = 0.8;
          let scale = 1;
          
          // Progressive compression loop
          const tryCompress = () => {
            canvas.width = width * scale;
            canvas.height = height * scale;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            const result = canvas.toDataURL('image/jpeg', quality).split(',')[1];
            
            if (result.length > targetKB * 1024 && (quality > 0.3 || scale > 0.3)) {
              if (quality > 0.3) quality -= 0.1;
              else scale -= 0.1;
              tryCompress();
            } else {
              console.log('Compressed:', Math.round(result.length/1024), 'KB (q=' + quality.toFixed(1) + ', s=' + scale.toFixed(1) + ')');
              resolve(result);
            }
          };
          
          // Start with size reduction if very large
          if (width > 1200) {
            scale = 1200 / width;
          }
          tryCompress();
        };
        img.onerror = () => resolve(base64); // Return original on error
        img.src = 'data:image/jpeg;base64,' + base64;
      });
    };

    // Copy to clipboard with iOS fallback
    const copyToClipboard = async (text) => {
      try {
        // Try modern clipboard API first
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(text);
          return true;
        }
      } catch (e) {
        console.log('Clipboard API failed, trying fallback');
      }
      
      // Fallback for iOS Safari and older browsers
      try {
        const textarea = document.createElement('textarea');
        textarea.value = text;
        textarea.style.position = 'fixed';
        textarea.style.left = '-9999px';
        textarea.style.top = '0';
        textarea.setAttribute('readonly', '');
        document.body.appendChild(textarea);
        textarea.select();
        textarea.setSelectionRange(0, textarea.value.length); // iOS specific
        const success = document.execCommand('copy');
        document.body.removeChild(textarea);
        return success;
      } catch (e) {
        console.error('Copy failed:', e);
        return false;
      }
    };

    // HuggingFace API
    // AI calls now go through our server-side API (key kept secret)
    const AI_API = '/api/ai';

    // Expense categories with translations
    const EXPENSE_CATEGORIES = [
      { id: 'funeral_home', sm: 'Fale Maliu', mi: 'Whare Mate', en: 'Funeral Home', icon: 'üèõÔ∏è', group: 'tangihanga', keywords: ['funeral', 'mortuary', 'chapel', 'death', 'undertaker'] },
      { id: 'casket', sm: 'Pusa', mi: 'KƒÅwhena', en: 'Casket', icon: '‚ö±Ô∏è', group: 'tangihanga', keywords: ['casket', 'coffin', 'urn', 'burial'] },
      { id: 'plot', sm: 'Tuugamau', mi: 'UrupƒÅ', en: 'Plot', icon: 'ü™¶', group: 'tangihanga', keywords: ['cemetery', 'plot', 'grave', 'burial', 'urupa'] },
      { id: 'flowers', sm: "FugƒÅlƒÅ'au", mi: 'Putiputi', en: 'Flowers', icon: 'üíê', group: 'tangihanga', keywords: ['flower', 'florist', 'wreath', 'bouquet', 'floral'] },
      { id: 'venue', sm: 'Nofoaga', mi: 'Marae', en: 'Venue', icon: 'üè†', group: 'tangihanga', keywords: ['venue', 'hall', 'marae', 'hire', 'community'] },
      { id: 'church', sm: 'Lotu', mi: 'Karakia', en: 'Church', icon: '‚õ™', group: 'tangihanga', keywords: ['church', 'parish', 'minister', 'pastor', 'service', 'donation'] },
      { id: 'printing', sm: 'Lolomi', mi: 'Pepa', en: 'Service Sheets', icon: 'üìÑ', group: 'tangihanga', keywords: ['print', 'printing', 'service sheet', 'program', 'order of service', 'warehouse stationery', 'officeworks'] },
      { id: 'thankyou', sm: "Fa'afetai", mi: 'Mihi', en: 'Thank You Cards', icon: 'üíå', group: 'tangihanga', keywords: ['card', 'thank you', 'postage', 'stamps', 'stationery'] },
      { id: 'clothing', sm: 'Ofu', mi: 'KƒÅkahu', en: 'Clothing', icon: 'üëî', group: 'tangihanga', keywords: ['clothing', 'dress', 'suit', 'shirt', 'shoes', 'kmart', 'farmers', 'hallensteins', 'glassons'] },
      { id: 'kai', sm: "Mea'ai", mi: 'Kai', en: 'Groceries', icon: 'üõí', group: 'kai', keywords: ['countdown', 'pak n save', 'new world', 'supermarket', 'grocery', 'food', 'woolworths', 'fresh choice', 'four square', 'dairy'] },
      { id: 'catering', sm: 'Taumafa', mi: 'HƒÅkari', en: 'Catering', icon: 'üçΩÔ∏è', group: 'kai', keywords: ['catering', 'caterer', 'buffet', 'restaurant', 'takeaway', 'kfc', 'mcdonald', 'subway', 'pizza', 'sushi'] },
      { id: 'drinks', sm: 'Vai', mi: 'Inu', en: 'Drinks', icon: 'ü•§', group: 'kai', keywords: ['drink', 'beverage', 'water', 'juice', 'coffee', 'tea', 'liquor', 'beer', 'wine', 'super liquor', 'liquorland'] },
      { id: 'petrol', sm: 'Penisini', mi: 'Penehƒ´ni', en: 'Petrol', icon: '‚õΩ', group: 'travel', keywords: ['petrol', 'gas', 'fuel', 'z station', 'bp', 'mobil', 'gull', 'caltex', 'npd', 'waitomo'] },
      { id: 'flights', sm: "Va'alele", mi: 'Rererangi', en: 'Flights', icon: '‚úàÔ∏è', group: 'travel', keywords: ['flight', 'air new zealand', 'jetstar', 'airline', 'airport', 'ticket', 'travel'] },
      { id: 'accommodation', sm: 'Fale Moe', mi: 'Whare Moe', en: 'Accommodation', icon: 'üõèÔ∏è', group: 'travel', keywords: ['hotel', 'motel', 'airbnb', 'accommodation', 'stay', 'booking', 'lodge'] },
      { id: 'power', sm: 'Eletise', mi: 'Hiko', en: 'Power', icon: 'üí°', group: 'utilities', keywords: ['power', 'electricity', 'electric', 'meridian', 'genesis', 'contact', 'mercury', 'trustpower'] },
      { id: 'rubbish', sm: 'Lapisi', mi: 'Para', en: 'Rubbish', icon: 'üóëÔ∏è', group: 'utilities', keywords: ['rubbish', 'waste', 'bin', 'skip', 'cleanup', 'tip', 'dump', 'recycling', 'landfill', 'transfer station', 'refuse', 'disposal', 'trash'] },
      { id: 'misc', sm: 'Isi Mea', mi: 'ƒítahi Atu', en: 'Other', icon: 'üì¶', group: 'other', keywords: [] }
    ];

    // Gift/Koha categories
    const GIFT_CATEGORIES = [
      { id: 'aiga', sm: "ƒÄiga", mi: 'WhƒÅnau', en: 'Family', icon: 'üë®‚Äçüë©‚Äçüëß‚Äçüë¶', color: '#ec4899', keywords: ['aunty', 'auntie', 'uncle', 'nana', 'grandma', 'grandpa', 'papa', 'mama', 'mum', 'dad', 'brother', 'sister', 'cousin', 'niece', 'nephew', 'son', 'daughter', 'in-law', 'family', 'whƒÅnau', 'aiga', 'tina', 'tama'] },
      { id: 'uo', sm: 'Uo', mi: 'Hoa', en: 'Friends', icon: 'ü§ù', color: '#8b5cf6', keywords: ['friend', 'mate', 'bro', 'sis', 'cuz', 'bestie', 'crew', 'boys', 'girls', 'gang'] },
      { id: 'galuega', sm: 'Galuega', mi: 'Mahi', en: 'Work', icon: 'üíº', color: '#06b6d4', keywords: ['work', 'office', 'team', 'staff', 'company', 'ltd', 'limited', 'inc', 'corp', 'business', 'employer', 'colleague', 'workmate', 'department', 'manager', 'boss'] },
      { id: 'lotu', sm: 'Lotu', mi: 'HƒÅhi', en: 'Church', icon: '‚õ™', color: '#f59e0b', keywords: ['church', 'parish', 'congregation', 'pastor', 'reverend', 'rev', 'father', 'minister', 'bishop', 'st ', 'saint', 'methodist', 'catholic', 'presbyterian', 'baptist', 'assembly', 'efks', 'pipc', 'cccs', 'aog'] },
      { id: 'nuu', sm: "Nu'u", mi: 'Hapori', en: 'Community', icon: 'üèòÔ∏è', color: '#10b981', keywords: ['community', 'club', 'association', 'group', 'society', 'council', 'committee', 'trust', 'foundation', 'organisation', 'organization', 'sports', 'rugby', 'league', 'netball', 'school', 'college'] },
      { id: 'isi', sm: 'Isi', mi: 'ƒítahi', en: 'Other', icon: 'üéÅ', color: '#64748b', keywords: [] }
    ];

    const CATEGORY_GROUPS = {
      tangihanga: { name: 'Maliu ‚Ä¢ Tangihanga ‚Ä¢ Funeral', color: '#a855f7', colors: ['#a855f7', '#9333ea', '#7c3aed', '#6d28d9', '#5b21b6', '#4c1d95', '#7e22ce', '#581c87', '#4a044e'] },
      kai: { name: "Mea'ai ‚Ä¢ Kai ‚Ä¢ Food", color: '#f97316', colors: ['#f97316', '#ea580c', '#fb923c'] },
      travel: { name: 'Malaga ‚Ä¢ Haerenga ‚Ä¢ Travel', color: '#06b6d4', colors: ['#06b6d4', '#0891b2', '#22d3ee'] },
      utilities: { name: 'Utilities', color: '#eab308', colors: ['#eab308', '#ca8a04'] },
      other: { name: 'Isi Mea ‚Ä¢ ƒítahi Atu ‚Ä¢ Other', color: '#64748b', colors: ['#64748b'] }
    };

    // Receipt storage helper
    const ReceiptStore = {
      save: (id, data) => { 
        try { 
          localStorage.setItem('koha_receipt_' + id, JSON.stringify(data));
        } catch (e) {
          console.error('Failed to save receipt:', e);
        }
      },
      get: (id) => { 
        try { 
          return JSON.parse(localStorage.getItem('koha_receipt_' + id)) || null;
        } catch { return null; }
      },
      delete: (id) => {
        try {
          localStorage.removeItem('koha_receipt_' + id);
        } catch {}
      },
      getAll: () => {
        const receipts = [];
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key?.startsWith('koha_receipt_')) {
            const id = key.replace('koha_receipt_', '');
            const data = ReceiptStore.get(id);
            if (data) receipts.push({ id, ...data });
          }
        }
        return receipts;
      }
    };

    // Cloud sync using our own Netlify Function
    const CloudSync = {
      create: async (data) => {
        try {
          const res = await fetch('/api/sync', {
            method: 'POST',
            headers: { 
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
          });
          
          console.log('CloudSync.create: Response status', res.status);
          
          const json = await res.json();
          console.log('CloudSync.create: Response', json);
          
          if (!res.ok || !json.success) {
            return { error: json.error || 'unknown', status: res.status };
          }
          
          return json.id;
        } catch (e) { 
          console.error('CloudSync.create ERROR:', e);
          return { error: 'fetch_error', message: e.message };
        }
      },
      
      get: async (syncId) => {
        try {
          console.log('CloudSync.get: Fetching', syncId);
          const res = await fetch('/api/sync?id=' + syncId.toUpperCase());
          
          if (!res.ok) {
            console.error('CloudSync.get error:', res.status);
            return null;
          }
          
          const json = await res.json();
          return json.success ? json.data : null;
        } catch (e) { 
          console.error('Get sync failed:', e); 
          return null; 
        }
      },
      
      update: async (syncId, newData) => {
        try {
          const res = await fetch('/api/sync?id=' + syncId.toUpperCase(), {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(newData)
          });
          
          const json = await res.json();
          return json.success ? json.data : false;
        } catch (e) { 
          console.error('Update sync failed:', e); 
          return false; 
        }
      }
    };

    // AI Category Validator
    const AIValidator = {
      // Common Samoan/Polynesian names that suggest family/community
      samoanNames: ['tui', 'sio', 'afa', 'manu', 'tafa', 'latu', 'vili', 'peni', 'simi', 'ioane', 'petelo', 'paulo', 'matai', 'tama', 'sina', 'losa', 'mele', 'ana', 'maria', 'elisapeta', 'fatu', 'leota', 'taufa', 'lolo', 'ese', 'vaa', 'tagaloa', 'savea', 'tuigamala', 'aumua', 'leaupepe', 'tapuai', 'faalogo', 'fuimaono', 'leilua', 'misa', 'papalii', 'tofaeono', 'tuimalealiifano', 'malietoa', 'tupua', 'mataafa'],
      
      // Quick validation for gift categories based on donor name
      suggestGiftCategory: (donorName, existingGifts = []) => {
        if (!donorName) return null;
        const name = donorName.toLowerCase().trim();
        const nameParts = name.split(/\s+/);
        const lastName = nameParts.length > 1 ? nameParts[nameParts.length - 1] : null;
        const firstName = nameParts[0];
        
        // Check keyword matches first
        for (const cat of GIFT_CATEGORIES) {
          if (cat.id === 'isi') continue;
          for (const kw of cat.keywords) {
            if (name.includes(kw.toLowerCase())) {
              return {
                categoryId: cat.id,
                category: cat,
                keyword: kw,
                confidence: kw.length > 4 ? 85 : 70,
                reason: `Name contains "${kw}"`
              };
            }
          }
        }
        
        // Check if surname matches someone already in Family
        if (lastName && lastName.length > 2) {
          const familyGifts = existingGifts.filter(g => g.category === 'aiga');
          for (const fg of familyGifts) {
            const fgParts = fg.donor.toLowerCase().split(/\s+/);
            const fgLastName = fgParts.length > 1 ? fgParts[fgParts.length - 1] : null;
            if (fgLastName && fgLastName === lastName) {
              return {
                categoryId: 'aiga',
                category: GIFT_CATEGORIES.find(c => c.id === 'aiga'),
                confidence: 80,
                reason: `Same surname as ${fg.donor} (Family)`
              };
            }
          }
        }
        
        // Check for Samoan/Polynesian names - likely family or community
        const isSamoanName = AIValidator.samoanNames.some(sn => 
          firstName.includes(sn) || (lastName && lastName.includes(sn)) || name.includes(sn)
        );
        if (isSamoanName) {
          // If we already have gifts, check if any Samoan names are in specific categories
          const samoanGifts = existingGifts.filter(g => {
            const gName = g.donor.toLowerCase();
            return AIValidator.samoanNames.some(sn => gName.includes(sn));
          });
          if (samoanGifts.length > 0) {
            // Follow the pattern of existing Samoan names
            const mostCommonCat = samoanGifts.reduce((acc, g) => {
              acc[g.category] = (acc[g.category] || 0) + 1;
              return acc;
            }, {});
            const topCat = Object.entries(mostCommonCat).sort((a, b) => b[1] - a[1])[0];
            if (topCat && topCat[1] >= 2) {
              const cat = GIFT_CATEGORIES.find(c => c.id === topCat[0]);
              if (cat) {
                return {
                  categoryId: topCat[0],
                  category: cat,
                  confidence: 65,
                  reason: `Samoan name, similar to others in ${cat.en}`
                };
              }
            }
          }
          // Default Samoan names to Family if no pattern
          return {
            categoryId: 'aiga',
            category: GIFT_CATEGORIES.find(c => c.id === 'aiga'),
            confidence: 60,
            reason: 'Samoan name - likely whƒÅnau'
          };
        }
        
        return null;
      },

      // AI-powered gift category validation
      validateGift: async (gift, currentCategory) => {
        const prompt = `<s>[INST] You are categorizing a gift/koha donor for a funeral fund tracker in New Zealand.

Donor name: "${gift.donor}"
Amount: $${gift.amount}
Current Category: "${currentCategory?.en || 'Other'}"
Note: "${gift.note || 'none'}"

Available categories:
- Family (relatives: aunty, uncle, cousin, grandma, in-laws, whƒÅnau, ƒÅiga)
- Friends (personal friends, mates, social connections)
- Work (employers, colleagues, companies, businesses - look for "Ltd", "Limited", "Inc", company names)
- Church (religious organizations, parishes, ministers, pastors - look for "St ", "Parish", "Church", "Rev")
- Community (clubs, associations, sports teams, schools, trusts, foundations)
- Other (if nothing else fits)

Analyze the donor name and any clues. Company names often end in Ltd/Limited. Church donations often include "St" or religious titles.

Respond with ONLY valid JSON:
{"correct": true/false, "suggested": "category name if incorrect", "confidence": 0-100, "reason": "brief explanation"}
[/INST]</s>`;

        try {
          const response = await fetch('/api/ai', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              action: 'validate',
              data: { prompt, maxTokens: 150 }
            })
          });

          if (!response.ok) return null;

          const apiResult = await response.json();
          if (!apiResult.success) return null;
          
          const text = apiResult.result[0]?.generated_text || '';
          const jsonMatch = text.match(/\{[^}]+\}/);
          if (jsonMatch) {
            return JSON.parse(jsonMatch[0]);
          }
          return null;
        } catch (e) {
          console.error('AI gift validation failed:', e);
          return null;
        }
      },
      validateExpense: async (expense, category) => {
        const isOther = category.id === 'misc';
        const prompt = `<s>[INST] You are a expense categorization assistant for a funeral/tangihanga fund tracker in New Zealand.

Given this expense:
- Description: "${expense.description || 'No description'}"
- Amount: $${expense.amount}
- Current Category: "${category.en}"${isOther ? ' (This is a catch-all category - try to find a better fit!)' : ''}

Available categories:
- Funeral Home (funeral services, mortuary)
- Casket (coffins, urns)
- Plot (cemetery, burial plots)
- Flowers (florist, wreaths)
- Venue (hall hire, marae)
- Church (donations, minister fees)
- Service Sheets (printing programs)
- Thank You Cards (cards, postage)
- Clothing (funeral attire)
- Groceries (supermarket food - Countdown, Pak n Save, New World)
- Catering (restaurants, takeaway, KFC, etc)
- Drinks (beverages, alcohol)
- Petrol (fuel - Z, BP, Mobil, Gull)
- Flights (air travel)
- Accommodation (hotels, motels)
- Power (electricity bills)
- Rubbish (waste disposal, landfill, transfer station, skip bins, cleanup)
- Other (ONLY if nothing else fits)

${isOther ? 'IMPORTANT: The item is currently in "Other". Look carefully at the description and try to find a more specific category. Only confirm "Other" if no other category fits.' : 'Analyze if the current category is correct.'}

Respond with ONLY valid JSON:
{"correct": true/false, "suggested": "category name if incorrect", "confidence": 0-100, "reason": "brief explanation"}
[/INST]</s>`;

        try {
          const response = await fetch('/api/ai', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              action: 'validate',
              data: { prompt, maxTokens: 150 }
            })
          });

          if (!response.ok) {
            console.error('AI API error');
            return null;
          }

          const apiResult = await response.json();
          if (!apiResult.success) return null;
          
          const text = apiResult.result[0]?.generated_text || '';
          
          // Extract JSON from response
          const jsonMatch = text.match(/\{[^}]+\}/);
          if (jsonMatch) {
            return JSON.parse(jsonMatch[0]);
          }
          return null;
        } catch (e) {
          console.error('AI validation failed:', e);
          return null;
        }
      },

      // Local keyword-based validation (fast, no API)
      quickValidate: (expense, category) => {
        const desc = (expense.description || '').toLowerCase();
        
        // If in "Other/misc" and has a description, be very suspicious
        const isOther = category.id === 'misc';
        
        if (!desc) {
          return { 
            correct: !isOther, 
            confidence: isOther ? 30 : 50, 
            reason: isOther ? 'Item in Other with no description - may need review' : 'No description to analyze'
          };
        }

        // Check if description matches current category keywords
        const currentMatch = category.keywords?.some(kw => desc.includes(kw.toLowerCase()));
        
        // Check all categories for better match
        let bestMatch = null;
        let bestScore = 0;
        let matchedKeyword = '';
        
        for (const cat of EXPENSE_CATEGORIES) {
          if (cat.id === 'misc') continue;
          for (const kw of (cat.keywords || [])) {
            if (desc.includes(kw.toLowerCase())) {
              const score = kw.length; // Longer keywords = more specific = better match
              if (score > bestScore) {
                bestScore = score;
                bestMatch = cat;
                matchedKeyword = kw;
              }
            }
          }
        }

        // If we found a better match
        if (bestMatch && bestMatch.id !== category.id && bestScore > 0) {
          return {
            correct: false,
            suggested: bestMatch.en,
            suggestedId: bestMatch.id,
            confidence: Math.min(95, 70 + Math.floor(bestScore / 2)),
            reason: `Description contains "${matchedKeyword}" which suggests ${bestMatch.en}`
          };
        }

        // If in Other but has description, still flag it for AI review
        if (isOther && desc) {
          return {
            correct: false,
            confidence: 40,
            needsAI: true,
            reason: `Item in "Other" with description "${desc}" - AI review recommended`
          };
        }

        return { correct: true, confidence: currentMatch ? 85 : 50, reason: currentMatch ? 'Keywords match category' : 'No strong indicators' };
      }
    };

    // Format currency
    const fmt = (n) => {
      const num = parseFloat(n) || 0;
      return '$' + num.toLocaleString('en-NZ', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    };

    // Format date
    const fmtDate = (d) => new Date(d).toLocaleDateString('en-NZ', { day: 'numeric', month: 'short' });
    const fmtDateFull = (d) => new Date(d).toLocaleDateString('en-NZ', { day: 'numeric', month: 'short', year: 'numeric' });

    // Generate random sync code
    const generateSyncCode = () => {
      const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
      let code = '';
      for (let i = 0; i < 6; i++) code += chars[Math.floor(Math.random() * chars.length)];
      return code;
    };

    // Pie Chart Component
    const PieChart = ({ data, size = 200, showLegend = true, title }) => {
      const total = data.reduce((a, d) => a + d.value, 0);
      if (total === 0) return null;

      let currentAngle = 0;
      const paths = data.filter(d => d.value > 0).map((d, i) => {
        const percentage = d.value / total;
        const angle = percentage * 360;
        const startAngle = currentAngle;
        const endAngle = currentAngle + angle;
        currentAngle = endAngle;

        const startRad = (startAngle - 90) * Math.PI / 180;
        const endRad = (endAngle - 90) * Math.PI / 180;
        const radius = size / 2 - 10;
        const cx = size / 2;
        const cy = size / 2;

        const x1 = cx + radius * Math.cos(startRad);
        const y1 = cy + radius * Math.sin(startRad);
        const x2 = cx + radius * Math.cos(endRad);
        const y2 = cy + radius * Math.sin(endRad);

        const largeArc = angle > 180 ? 1 : 0;

        const pathD = percentage === 1 
          ? `M ${cx} ${cy - radius} A ${radius} ${radius} 0 1 1 ${cx - 0.01} ${cy - radius} Z`
          : `M ${cx} ${cy} L ${x1} ${y1} A ${radius} ${radius} 0 ${largeArc} 1 ${x2} ${y2} Z`;

        return (
          <path
            key={i}
            d={pathD}
            fill={d.color}
            stroke="#0f172a"
            strokeWidth="2"
          />
        );
      });

      // Dynamic font size based on total length
      const totalStr = fmt(total);
      const fontSize = totalStr.length > 8 ? 12 : totalStr.length > 6 ? 14 : 18;

      return (
        <div className="flex flex-col items-center">
          {title && <p className="text-slate-400 text-sm font-medium mb-2">{title}</p>}
          <svg width={size} height={size} className="drop-shadow-lg">
            {paths}
            <circle cx={size/2} cy={size/2} r={size/4} fill="#0f172a" />
            <text x={size/2} y={size/2} textAnchor="middle" dy=".1em" fill="white" fontWeight="bold" style={{ fontSize: fontSize + 'px' }}>{totalStr}</text>
            <text x={size/2} y={size/2 + 14} textAnchor="middle" fill="#94a3b8" style={{ fontSize: '10px' }}>total</text>
          </svg>
          {showLegend && (
            <div className="mt-3 space-y-1 w-full max-w-xs">
              {data.filter(d => d.value > 0).map((d, i) => (
                <div key={i} className="flex items-center justify-between text-sm">
                  <div className="flex items-center gap-2">
                    <div className="w-3 h-3 rounded-full" style={{ backgroundColor: d.color }} />
                    <span className="text-slate-300 truncate max-w-[100px]">{d.label}</span>
                  </div>
                  <span className="text-slate-400 text-xs whitespace-nowrap">{fmt(d.value)} ({((d.value/total)*100).toFixed(0)}%)</span>
                </div>
              ))}
            </div>
          )}
        </div>
      );
    };

    // Progress Bar Component
    const ProgressBar = ({ progress, status, details }) => (
      <div className="bg-slate-900 rounded-xl p-4 mb-4">
        <div className="flex justify-between items-center mb-2">
          <span className="text-sm text-white font-medium">{status}</span>
          <span className="text-sm text-cyan-400">{progress}%</span>
        </div>
        <div className="h-2 bg-slate-800 rounded-full overflow-hidden">
          <div 
            className="h-full progress-animated rounded-full transition-all duration-300"
            style={{ width: `${progress}%` }}
          />
        </div>
        {details && <p className="text-slate-500 text-xs mt-2">{details}</p>}
      </div>
    );

    // Full-screen Scanning Overlay - much more visible!
    const ScanningOverlay = ({ visible, progress, status }) => {
      if (!visible) return null;
      
      const getEmoji = () => {
        if (progress < 30) return 'üì∑';
        if (progress < 60) return 'üîç';
        if (progress < 90) return '‚ú®';
        return '‚úÖ';
      };
      
      return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-slate-950/95 backdrop-blur-sm fade-in">
          <div className="text-center px-8 max-w-sm">
            <div className="relative w-32 h-32 mx-auto mb-8">
              <svg className="w-full h-full spin" style={{ animationDuration: '3s' }}>
                <circle cx="64" cy="64" r="60" fill="none" stroke="url(#scanGradient)" strokeWidth="4" strokeLinecap="round" strokeDasharray="280" strokeDashoffset={280 - (280 * progress / 100)} />
                <defs>
                  <linearGradient id="scanGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                    <stop offset="0%" stopColor="#06b6d4" />
                    <stop offset="50%" stopColor="#8b5cf6" />
                    <stop offset="100%" stopColor="#ec4899" />
                  </linearGradient>
                </defs>
              </svg>
              <div className="absolute inset-0 flex items-center justify-center">
                <span className="text-5xl scan-pulse">{getEmoji()}</span>
              </div>
            </div>
            <div className="text-5xl font-bold text-white mb-2">{progress}%</div>
            <div className="text-lg text-cyan-400 font-medium mb-4">{status || 'Processing...'}</div>
            <div className="h-2 bg-slate-800 rounded-full overflow-hidden mb-4">
              <div className="h-full bg-gradient-to-r from-cyan-500 via-purple-500 to-pink-500 rounded-full transition-all duration-300 ease-out shimmer" style={{ width: `${progress}%` }} />
            </div>
            <p className="text-slate-500 text-sm">
              {progress < 30 ? 'Reading your photo...' :
               progress < 60 ? 'Extracting text from receipt...' :
               progress < 90 ? 'Finding amounts and details...' :
               'Almost done!'}
            </p>
          </div>
        </div>
      );
    };

    const App = () => {
      // Check if we're returning from a scan reload
      const [screen, setScreen] = useState(() => {
        const returnTo = sessionStorage.getItem('return_to_screen');
        if (returnTo) {
          sessionStorage.removeItem('return_to_screen');
          return returnTo;
        }
        return 'home';
      });
      const [gifts, setGifts] = useState(() => S.get('gifts', []));
      const [expenses, setExpenses] = useState(() => S.get('expenses', []));
      const [transfers, setTransfers] = useState(() => S.get('transfers', []));
      const [editingItem, setEditingItem] = useState(null);
      const [syncCode, setSyncCode] = useState(() => S.get('syncCode', null));
      const [syncBinId, setSyncBinId] = useState(() => S.get('syncBinId', null));
      const [syncing, setSyncing] = useState(false);
      const [lastSync, setLastSync] = useState(() => S.get('lastSync', null));
      const [scanResult, setScanResult] = useState(null);
      const [scanning, setScanning] = useState(false);
      const [catLang, setCatLang] = useState(() => S.get('catLang', 'all'));
      
      // Validation state
      const [validationResults, setValidationResults] = useState(() => S.get('validationResults', {}));
      const [giftValidationResults, setGiftValidationResults] = useState(() => S.get('giftValidationResults', {}));
      const [isValidating, setIsValidating] = useState(false);
      const [validationProgress, setValidationProgress] = useState(0);
      const [validationStatus, setValidationStatus] = useState('');
      const [validationDetails, setValidationDetails] = useState('');

      // Category name helper
      const getCategoryById = (id) => EXPENSE_CATEGORIES.find(c => c.id === id) || EXPENSE_CATEGORIES[EXPENSE_CATEGORIES.length - 1];
      const getGiftCategoryById = (id) => GIFT_CATEGORIES.find(c => c.id === id) || GIFT_CATEGORIES[GIFT_CATEGORIES.length - 1];
      const getCategoryName = (cat) => {
        if (catLang === 'all') return `${cat.sm} ‚Ä¢ ${cat.mi} ‚Ä¢ ${cat.en}`;
        return cat[catLang] || cat.en;
      };

      // Persist data locally
      useEffect(() => { S.set('gifts', gifts) }, [gifts]);
      useEffect(() => { S.set('expenses', expenses) }, [expenses]);
      useEffect(() => { S.set('transfers', transfers) }, [transfers]);
      useEffect(() => { S.set('syncCode', syncCode) }, [syncCode]);
      useEffect(() => { S.set('syncBinId', syncBinId) }, [syncBinId]);
      useEffect(() => { S.set('lastSync', lastSync) }, [lastSync]);
      useEffect(() => { S.set('catLang', catLang) }, [catLang]);
      useEffect(() => { S.set('validationResults', validationResults) }, [validationResults]);
      useEffect(() => { S.set('giftValidationResults', giftValidationResults) }, [giftValidationResults]);

      // Sync from cloud on page load if connected
      const initialSyncDone = useRef(false);
      useEffect(() => {
        if (syncBinId && !initialSyncDone.current) {
          initialSyncDone.current = true;
          syncFromCloud();
        }
      }, [syncBinId]);

      // Sync to cloud when page closes/hides
      useEffect(() => {
        if (!syncBinId) return;
        
        const handleSync = () => {
          if (syncBinId && !syncing) {
            const data = JSON.stringify({ gifts, expenses, transfers });
            navigator.sendBeacon?.(`/api/sync?id=${syncBinId}`, new Blob([data], { type: 'application/json' }));
          }
        };
        
        const handleVisibilityChange = () => {
          if (document.visibilityState === 'hidden') {
            handleSync();
          }
        };
        
        document.addEventListener('visibilitychange', handleVisibilityChange);
        window.addEventListener('beforeunload', handleSync);
        
        return () => {
          document.removeEventListener('visibilitychange', handleVisibilityChange);
          window.removeEventListener('beforeunload', handleSync);
        };
      }, [syncBinId, gifts, expenses, transfers, syncing]);

      // Instant sync to cloud after any data change (debounced 1 second)
      const syncTimeout = useRef(null);
      const dataInitialized = useRef(false);
      useEffect(() => {
        if (!syncBinId) return;
        
        if (!dataInitialized.current) {
          dataInitialized.current = true;
          return;
        }
        
        if (syncTimeout.current) clearTimeout(syncTimeout.current);
        
        syncTimeout.current = setTimeout(() => {
          console.log('Auto-syncing after data change...');
          syncToCloud();
        }, 1000);
        
        return () => {
          if (syncTimeout.current) clearTimeout(syncTimeout.current);
        };
      }, [gifts, expenses, transfers, syncBinId]);

      // FIX #9: Poll for other users' changes every 30 seconds (was 10)
      useEffect(() => {
        if (!syncBinId) return;
        
        const pollInterval = setInterval(() => {
          if (!syncing) {
            console.log('Polling for updates...');
            syncFromCloud();
          }
        }, 30000); // Changed from 10000 to 30000
        
        return () => clearInterval(pollInterval);
      }, [syncBinId, syncing]);

      // Validate new expenses automatically
      useEffect(() => {
        const newExpenses = expenses.filter(e => !validationResults[e.id]);
        if (newExpenses.length > 0 && !isValidating) {
          validateExpenses(newExpenses, false);
        }
      }, [expenses]);

      // Sync functions
      const syncToCloud = async () => {
        if (!syncBinId || syncing) return;
        console.log('Syncing to cloud...');
        setSyncing(true);
        const success = await CloudSync.update(syncBinId, { gifts, expenses, transfers });
        if (success) {
          setLastSync(Date.now());
          console.log('Sync to cloud complete');
        } else {
          console.error('Sync to cloud failed');
        }
        setSyncing(false);
      };

      const syncFromCloud = async () => {
        if (!syncBinId || syncing) return;
        console.log('Syncing from cloud...');
        setSyncing(true);
        const data = await CloudSync.get(syncBinId);
        if (data) {
          const mergeArrays = (local, cloud) => {
            const map = new Map();
            [...local, ...cloud].forEach(item => map.set(item.id, item));
            return Array.from(map.values());
          };
          setGifts(mergeArrays(gifts, data.gifts || []));
          setExpenses(mergeArrays(expenses, data.expenses || []));
          setTransfers(mergeArrays(transfers, data.transfers || []));
          setLastSync(Date.now());
          console.log('Sync from cloud complete');
        } else {
          console.error('Sync from cloud failed or no data');
        }
        setSyncing(false);
      };

      const createSync = async () => {
        setSyncing(true);
        try {
          const binId = await CloudSync.create({ gifts, expenses, transfers });
          if (binId && typeof binId === 'string') {
            // The server returns a 5-letter code - use it as both the display code AND the API ID
            setSyncCode(binId);
            setSyncBinId(binId);
            setLastSync(Date.now());
            setSyncing(false);
            return binId;
          }
        } catch (e) {
          console.error('createSync error:', e);
        }
        setSyncing(false);
        return null;
      };

      // Validation function
      const validateExpenses = async (expensesToValidate = expenses, useAI = false, includeGifts = false) => {
        try {
          setIsValidating(true);
          setValidationProgress(0);
          setValidationStatus('üîç Starting validation...');
          
          const results = { ...validationResults };
          const giftResults = { ...giftValidationResults };
          const giftsToValidate = includeGifts ? gifts : [];
          
          // Filter out already dismissed items - don't re-validate them
          const expensesToActuallyValidate = expensesToValidate.filter(e => {
            const existing = results[e.id];
            return !existing?.dismissed; // Skip if dismissed
          });
          
          const totalExpenses = expensesToActuallyValidate.length;
          const totalGifts = giftsToValidate.length;
          const total = totalExpenses + totalGifts;
          let processed = 0;
          
          // Validate expenses
          for (let i = 0; i < totalExpenses; i++) {
            const expense = expensesToActuallyValidate[i];
            const category = getCategoryById(expense.category);
            
            processed++;
            setValidationProgress(Math.round((processed / total) * 100));
            setValidationStatus(`üîç Expenses ${i + 1}/${totalExpenses}`);
            setValidationDetails(expense.description || category.en);

          // Quick local validation first
          let result = AIValidator.quickValidate(expense, category);
          
          // If quick validation is uncertain, in Other category, or needs AI - use AI
          const shouldUseAI = useAI && (!result.correct || result.confidence < 70 || result.needsAI || category.id === 'misc');
          
          if (shouldUseAI) {
            setValidationStatus(`ü§ñ AI analyzing expense ${i + 1}/${totalExpenses}`);
            const aiResult = await AIValidator.validateExpense(expense, category);
            if (aiResult) {
              result = {
                ...result,
                aiAnalyzed: true,
                aiSuggested: aiResult.suggested,
                aiConfidence: aiResult.confidence,
                aiReason: aiResult.reason,
                correct: aiResult.correct
              };
              
              // Map AI suggestion to category ID
              if (!aiResult.correct && aiResult.suggested) {
                const suggestedCat = EXPENSE_CATEGORIES.find(c => 
                  c.en.toLowerCase() === aiResult.suggested.toLowerCase()
                );
                if (suggestedCat) {
                  result.suggestedId = suggestedCat.id;
                  result.suggested = suggestedCat.en;
                }
              }
            }
            // Small delay to avoid rate limiting
            await new Promise(r => setTimeout(r, 500));
          }
          
          // Preserve dismissed flag if it was set
          const existingResult = results[expense.id];
          results[expense.id] = {
            ...result,
            validatedAt: Date.now(),
            originalCategory: expense.category,
            dismissed: existingResult?.dismissed || false
          };
        }
        
        // Validate gifts (if AI mode and includeGifts)
        if (useAI && includeGifts) {
          for (let i = 0; i < totalGifts; i++) {
            const gift = giftsToValidate[i];
            const category = getGiftCategoryById(gift.category);
            
            processed++;
            setValidationProgress(Math.round((processed / total) * 100));
            setValidationStatus(`üéÅ Koha ${i + 1}/${totalGifts}`);
            setValidationDetails(gift.donor);

            // Quick local check first
            const quickSuggestion = AIValidator.suggestGiftCategory(gift.donor, gifts);
            let result = { correct: true, confidence: 50 };
            
            // If in Other or quick check suggests different category
            const isOther = !gift.category || gift.category === 'isi';
            const quickMismatch = quickSuggestion && quickSuggestion.categoryId !== gift.category;
            
            if (isOther || quickMismatch) {
              setValidationStatus(`ü§ñ AI analyzing koha ${i + 1}/${totalGifts}`);
              const aiResult = await AIValidator.validateGift(gift, category);
              
              if (aiResult) {
                result = {
                  aiAnalyzed: true,
                  correct: aiResult.correct,
                  aiSuggested: aiResult.suggested,
                  aiConfidence: aiResult.confidence,
                  aiReason: aiResult.reason
                };
                
                // Map AI suggestion to gift category ID
                if (!aiResult.correct && aiResult.suggested) {
                  const suggestedCat = GIFT_CATEGORIES.find(c => 
                    c.en.toLowerCase() === aiResult.suggested.toLowerCase()
                  );
                  if (suggestedCat) {
                    result.suggestedId = suggestedCat.id;
                    result.suggested = suggestedCat.en;
                  }
                }
              } else if (quickSuggestion) {
                // Fall back to quick suggestion if AI fails
                result = {
                  correct: false,
                  suggestedId: quickSuggestion.categoryId,
                  suggested: quickSuggestion.category.en,
                  confidence: quickSuggestion.confidence,
                  reason: quickSuggestion.reason || (quickSuggestion.keyword ? `Name contains "${quickSuggestion.keyword}"` : 'Pattern match')
                };
              }
              
              await new Promise(r => setTimeout(r, 500));
            }
            
            giftResults[gift.id] = {
              ...result,
              validatedAt: Date.now(),
              originalCategory: gift.category
            };
          }
        }
        
        setValidationResults(results);
        setGiftValidationResults(giftResults);
        setIsValidating(false);
        setValidationStatus('‚úÖ Validation complete!');
        setValidationDetails(`Checked ${totalExpenses} expenses${includeGifts ? ` + ${totalGifts} koha` : ''}`);
        
        setTimeout(() => {
          setValidationStatus('');
          setValidationDetails('');
        }, 3000);
        } catch (err) {
          console.error('Validation error:', err);
          setIsValidating(false);
          setValidationStatus('‚ùå Error during validation');
          setValidationDetails('Please try again');
          setTimeout(() => {
            setValidationStatus('');
            setValidationDetails('');
          }, 3000);
        }
      };

      // Apply suggestion
      const applySuggestion = (expenseId, suggestedCategoryId) => {
        setExpenses(prev => prev.map(e => 
          e.id === expenseId ? { ...e, category: suggestedCategoryId } : e
        ));
        setValidationResults(prev => ({
          ...prev,
          [expenseId]: { ...prev[expenseId], correct: true, applied: true }
        }));
      };

      // Dismiss suggestion
      const dismissSuggestion = (expenseId) => {
        setValidationResults(prev => ({
          ...prev,
          [expenseId]: { ...prev[expenseId], correct: true, dismissed: true }
        }));
      };

      // Apply gift suggestion
      const applyGiftSuggestion = (giftId, suggestedCategoryId) => {
        setGifts(prev => prev.map(g => 
          g.id === giftId ? { ...g, category: suggestedCategoryId } : g
        ));
        setGiftValidationResults(prev => ({
          ...prev,
          [giftId]: { ...prev[giftId], correct: true, applied: true }
        }));
      };

      // Dismiss gift suggestion
      const dismissGiftSuggestion = (giftId) => {
        setGiftValidationResults(prev => ({
          ...prev,
          [giftId]: { ...prev[giftId], correct: true, dismissed: true }
        }));
      };

      // Global API logger - saves to localStorage for debugging
      const apiLog = (msg) => {
        const timestamp = new Date().toLocaleTimeString();
        const entry = '[' + timestamp + '] ' + msg;
        console.log('[API] ' + msg);
        try {
          const existing = localStorage.getItem('scan_debug_log') || '';
          localStorage.setItem('scan_debug_log', existing + '\n' + entry);
        } catch (e) {}
      };

      // FIX #6/#10: Receipt scanning WITHOUT forced reload
      // This now just returns the result and lets the caller handle state updates
      const scanReceipt = async (imageData, onProgress) => {
        apiLog('=== scanReceipt called (Google Cloud Vision) ===');
        apiLog('Image data length: ' + (imageData?.length || 0) + ' chars (' + Math.round(imageData?.length / 1024) + 'KB)');
        setScanning(true);
        setScanResult(null);
        
        try {
          // Progress simulation for UI feedback
          if (onProgress) onProgress(10);
          apiLog('Sending to Google Cloud Vision...');
          
          // Call our server-side Vision API function
          const response = await fetch('/api/vision', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ image: imageData })
          });
          
          if (onProgress) onProgress(60);
          
          const result = await response.json();
          
          if (!response.ok || result.error) {
            apiLog('Vision API error: ' + (result.error || 'Unknown error') + (result.details ? ' - ' + result.details.substring(0, 200) : '') + (result.code ? ' (code: ' + result.code + ')' : ''));
            throw new Error(result.error || 'Vision API failed');
          }
          
          if (onProgress) onProgress(80);
          
          const text = result.text || '';
          apiLog('OCR complete. Text length: ' + text.length);
          apiLog('Raw text preview: ' + text.substring(0, 300).replace(/\n/g, ' | '));
          
          // Parse the text to extract receipt info
          const parsedData = parseReceiptText(text);
          apiLog('Parsed: total=' + parsedData.total + ', vendor=' + parsedData.vendor + ', category=' + parsedData.category);
          if (parsedData.subtotal) apiLog('Subtotal: ' + parsedData.subtotal);
          if (parsedData.gst) apiLog('GST: ' + parsedData.gst);
          if (parsedData.discount) apiLog('Discount: ' + parsedData.discount);
          if (parsedData.paymentMethod) apiLog('Payment: ' + parsedData.paymentMethod);
          
          if (onProgress) onProgress(100);
          
          const finalResult = {
            total: parsedData.total,
            vendor: parsedData.vendor,
            date: parsedData.date,
            time: parsedData.time,
            items: parsedData.items,
            category: parsedData.category,
            // Receipt details
            subtotal: parsedData.subtotal,
            gst: parsedData.gst,
            discount: parsedData.discount,
            cashOut: parsedData.cashOut,
            change: parsedData.change,
            paymentMethod: parsedData.paymentMethod,
            cardLastFour: parsedData.cardLastFour,
            // Meta
            rawText: text,
            originalImage: imageData,
            scannedAt: new Date().toISOString()
          };

          // FIX: Instead of reloading, just save to ScanSession and return
          // The caller will update React state directly
          ScanSession.save({
            image: imageData,
            vendor: parsedData.vendor,
            total: parsedData.total,
            category: parsedData.category,
            date: parsedData.date,
            items: parsedData.items,
            rawText: text,
            subtotal: parsedData.subtotal,
            gst: parsedData.gst,
            paymentMethod: parsedData.paymentMethod
          });

          apiLog('Final result: total=' + finalResult.total + ', vendor=' + finalResult.vendor);
          setScanResult(finalResult);
          setScanning(false);
          return finalResult;
          
        } catch (e) {
          apiLog('ERROR in scanReceipt: ' + e.message);
          setScanning(false);
          
          return {
            total: 0,
            vendor: '',
            category: 'misc',
            originalImage: imageData,
            scannedAt: new Date().toISOString(),
            error: 'Scan failed - please enter details manually'
          };
        }
      };
      
      // Parse receipt text to extract structured data (unchanged from original)
      const parseReceiptText = (text) => {
        const lines = text.split('\n').map(l => l.trim()).filter(l => l.length > 0);
        const allText = lines.join(' ').toLowerCase();
        
        console.log('=== PARSING RECEIPT ===');
        console.log('Lines:', lines.length);
        
        let total = 0;
        let subtotal = 0;
        let gst = 0;
        let discount = 0;
        let cashOut = 0;
        let change = 0;
        let tendered = 0;
        let vendor = '';
        let date = null;
        let time = null;
        let category = 'misc';
        let paymentMethod = '';
        let cardLastFour = '';
        const items = [];
        const amounts = [];
        
        // Extract all amounts with context
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          const lineLower = line.toLowerCase();
          const position = i / lines.length;
          
          const regex = /\$?\s*(\d{1,5})[.,](\d{2})\b/g;
          let match;
          
          while ((match = regex.exec(line)) !== null) {
            const amount = parseFloat(match[1] + '.' + match[2]);
            if (amount <= 0 || amount >= 100000) continue;
            
            const info = {
              amount,
              line: i,
              position,
              text: lineLower,
              isTotal: /\btotal\b/i.test(lineLower) && !/sub.?total|cash.?total|tendered|paid|change|rounding/i.test(lineLower),
              isAmountDue: /amount\s*(due|owing)|balance\s*(due|owing)|to\s*pay|you\s*owe/i.test(lineLower),
              isGrandTotal: /grand\s*total/i.test(lineLower),
              isSaleTotal: /sale\s*total/i.test(lineLower),
              isSubtotal: /sub.?total/i.test(lineLower),
              isGst: /\bgst\b/i.test(lineLower) && !/gst\s*(no|num|#|reg|inc)/i.test(lineLower),
              isTax: /\btax\b/i.test(lineLower) && !/tax\s*(no|inv|inc)/i.test(lineLower),
              isTendered: /tender|tendered/i.test(lineLower),
              isCashPaid: /\bcash\b/i.test(lineLower) && !/cash\s*out|cash\s*back/i.test(lineLower) && position > 0.5,
              isPaid: /\bpaid\b/i.test(lineLower) && position > 0.6,
              isChange: /\bchange\b/i.test(lineLower) && !/no\s*change/i.test(lineLower),
              isEftpos: /eftpos/i.test(lineLower),
              isVisa: /\bvisa\b/i.test(lineLower),
              isMastercard: /master/i.test(lineLower),
              isCard: /\bcard\b/i.test(lineLower) && /\$|\.00|\.[\d]{2}/.test(line),
              isDiscount: /discount|saving|less|off|promo/i.test(lineLower),
              isCashOut: /cash\s*(out|back)/i.test(lineLower),
              isRounding: /round/i.test(lineLower),
              isInvoiceTotal: /invoice\s*total|total\s*(amount|due|payable)/i.test(lineLower),
              isBalanceDue: /balance\s*(due|owing|payable)/i.test(lineLower),
            };
            
            amounts.push(info);
          }
        }
        
        // Identify key amounts
        const totalCandidates = amounts.filter(a => 
          a.isGrandTotal || a.isTotal || a.isSaleTotal || 
          a.isInvoiceTotal || a.isAmountDue || a.isBalanceDue
        );
        const cardPaymentAmount = amounts.find(a => (a.isEftpos || a.isVisa || a.isMastercard) && a.position > 0.5);
        const tenderedAmount = amounts.find(a => a.isTendered || a.isCashPaid);
        const changeAmount = amounts.find(a => a.isChange);
        const subtotalAmount = amounts.find(a => a.isSubtotal);
        const gstAmount = amounts.find(a => (a.isGst || a.isTax) && a.amount < 5000);
        const discountAmount = amounts.find(a => a.isDiscount);
        const cashOutAmount = amounts.find(a => a.isCashOut);
        
        // Determine total using priority methods
        if (tenderedAmount && changeAmount) {
          const calculatedTotal = Math.round((tenderedAmount.amount - changeAmount.amount) * 100) / 100;
          if (calculatedTotal > 0) {
            total = calculatedTotal;
            tendered = tenderedAmount.amount;
            change = changeAmount.amount;
          }
        }
        
        if (total === 0 && changeAmount && !tenderedAmount) {
          const possibleTendered = amounts.filter(a => 
            a.position > 0.5 && a.amount > changeAmount.amount &&
            !a.isChange && !a.isSubtotal && !a.isGst && !a.isDiscount
          ).sort((a, b) => b.amount - a.amount);
          
          if (possibleTendered.length > 0) {
            total = possibleTendered[0].amount - changeAmount.amount;
            change = changeAmount.amount;
          }
        }
        
        if (total === 0 && totalCandidates.length > 0) {
          const sortedTotals = totalCandidates.sort((a, b) => b.position - a.position);
          for (const candidate of sortedTotals) {
            if (tenderedAmount && Math.abs(candidate.amount - tenderedAmount.amount) < 0.01) continue;
            total = candidate.amount;
            break;
          }
        }
        
        if (total === 0 && cardPaymentAmount && !changeAmount) {
          total = cardPaymentAmount.amount;
        }
        
        if (subtotalAmount) {
          subtotal = subtotalAmount.amount;
          if (gstAmount) {
            gst = gstAmount.amount;
            const calculatedTotal = Math.round((subtotal + gst) * 100) / 100;
            if (total === 0) total = calculatedTotal;
          }
        }
        
        if (total === 0) {
          const bottomAmounts = amounts
            .filter(a => a.position > 0.4 && !a.isDiscount && !a.isChange && !a.isRounding && !a.isCashOut && !a.isTendered && !a.isCashPaid)
            .sort((a, b) => b.amount - a.amount);
          
          if (bottomAmounts.length > 0) {
            const candidate = bottomAmounts[0];
            if (changeAmount && candidate.amount > changeAmount.amount) {
              total = candidate.amount - changeAmount.amount;
            } else {
              total = candidate.amount;
            }
          }
        }
        
        // Verify with NZ GST math
        if (total > 0 && !gst && !subtotal) {
          subtotal = Math.round((total / 1.15) * 100) / 100;
          gst = Math.round((total - subtotal) * 100) / 100;
        }
        
        if (discountAmount) discount = discountAmount.amount;
        if (cashOutAmount) cashOut = cashOutAmount.amount;
        if (gstAmount && !gst) gst = gstAmount.amount;
        
        // *** IMPROVED CATEGORY DETECTION: Check content FIRST, then vendor name ***
        // This ensures "Berghotel" with food items gets categorized as catering, not accommodation
        
        const headerText = lines.slice(0, 10).join(' ').toLowerCase();
        const fullText = lines.join(' ').toLowerCase();
        
        // Food/drink keywords - if found, it's food regardless of venue name
        const foodKeywords = ['latte', 'macchiato', 'cappuccino', 'espresso', 'flat white', 'long black', 'mocha',
                             'coffee', 'tea', 'hot chocolate', 'chai',
                             'burger', 'pizza', 'sandwich', 'salad', 'soup', 'pasta', 'rice', 'noodles',
                             'chicken', 'beef', 'pork', 'fish', 'lamb', 'steak', 'schnitzel', 'sausage',
                             'breakfast', 'lunch', 'dinner', 'brunch', 'meal', 'combo', 'fries', 'chips',
                             'eggs', 'bacon', 'toast', 'pancake', 'waffle', 'muffin', 'croissant', 'pastry',
                             'cake', 'cookie', 'dessert', 'ice cream', 'gelato',
                             'cafe', 'bistro', 'kitchen', 'grill', 'diner', 'eatery', 'takeaway', 'takeout',
                             'sushi', 'ramen', 'pho', 'curry', 'thai', 'chinese', 'indian', 'mexican'];
        
        const drinkKeywords = ['wine', 'beer', 'lager', 'ale', 'cider', 'cocktail', 'martini',
                              'vodka', 'whisky', 'whiskey', 'rum', 'gin', 'brandy', 'cognac',
                              'spirits', 'alcohol', 'liquor', 'champagne', 'prosecco'];
        
        // Check content FIRST - this takes priority over vendor name
        let hasFoodItems = foodKeywords.some(kw => fullText.includes(kw));
        let hasDrinkItems = drinkKeywords.some(kw => fullText.includes(kw));
        
        // If we find food items, categorize as catering regardless of venue name (e.g. "Berghotel")
        if (hasFoodItems) {
          category = 'catering';
          console.log('[Category] Content-based: catering (found food items in receipt)');
        } else if (hasDrinkItems) {
          category = 'drinks';
          console.log('[Category] Content-based: drinks (found drink items in receipt)');
        }
        
        // NZ stores dictionary - used for vendor name AND category (only if not already set by content)
        const nzStores = {
          'countdown': { name: 'Countdown', category: 'kai' },
          'woolworths': { name: 'Countdown', category: 'kai' },
          'pak n save': { name: 'Pak n Save', category: 'kai' },
          'pak\'n save': { name: 'Pak n Save', category: 'kai' },
          'paknsave': { name: 'Pak n Save', category: 'kai' },
          'new world': { name: 'New World', category: 'kai' },
          'fresh choice': { name: 'Fresh Choice', category: 'kai' },
          'four square': { name: 'Four Square', category: 'kai' },
          'kfc': { name: 'KFC', category: 'catering' },
          'mcdonald': { name: 'McDonalds', category: 'catering' },
          'burger king': { name: 'Burger King', category: 'catering' },
          'subway': { name: 'Subway', category: 'catering' },
          'pizza hut': { name: 'Pizza Hut', category: 'catering' },
          'domino': { name: 'Dominos', category: 'catering' },
          'starbucks': { name: 'Starbucks', category: 'catering' },
          'super liquor': { name: 'Super Liquor', category: 'drinks' },
          'liquorland': { name: 'Liquorland', category: 'drinks' },
          'z energy': { name: 'Z Energy', category: 'petrol' },
          'z station': { name: 'Z Energy', category: 'petrol' },
          'bp connect': { name: 'BP', category: 'petrol' },
          'bp ': { name: 'BP', category: 'petrol' },
          'mobil': { name: 'Mobil', category: 'petrol' },
          'gull': { name: 'Gull', category: 'petrol' },
          'caltex': { name: 'Caltex', category: 'petrol' },
          'npd': { name: 'NPD', category: 'petrol' },
          'waitomo': { name: 'Waitomo', category: 'petrol' },
          'kmart': { name: 'Kmart', category: 'clothing' },
          'farmers': { name: 'Farmers', category: 'clothing' },
          'the warehouse': { name: 'The Warehouse', category: 'clothing' },
          'warehouse stationery': { name: 'Warehouse Stationery', category: 'printing' },
          'florist': { name: 'Florist', category: 'flowers' },
          'interflora': { name: 'Interflora', category: 'flowers' },
          'funeral': { name: 'Funeral Services', category: 'funeral_home' },
          'mortuary': { name: 'Mortuary', category: 'funeral_home' },
          'motel': { name: 'Motel', category: 'accommodation' },
          'airbnb': { name: 'Airbnb', category: 'accommodation' },
          'air new zealand': { name: 'Air New Zealand', category: 'flights' },
          'jetstar': { name: 'Jetstar', category: 'flights' },
        };
        
        // Find vendor name from known stores (also set category if not already set by content)
        for (const [pattern, info] of Object.entries(nzStores)) {
          if (headerText.includes(pattern)) {
            vendor = info.name;
            if (category === 'misc') category = info.category; // Only set if content didn't find anything
            break;
          }
        }
        
        if (!vendor) {
          for (const [pattern, info] of Object.entries(nzStores)) {
            if (fullText.includes(pattern)) {
              vendor = info.name;
              if (category === 'misc') category = info.category;
              break;
            }
          }
        }
        
        // Handle "hotel" specially - only categorize as accommodation if NO food items found
        // This fixes the "Berghotel restaurant" case
        if (category === 'misc' && !hasFoodItems && !hasDrinkItems) {
          if (fullText.includes('hotel') || fullText.includes('lodge')) {
            // Only if it looks like actual accommodation (room, night, stay, check-in)
            if (/\b(room|night|stay|check.?in|check.?out|accommodation|booking|reservation)\b/i.test(fullText)) {
              category = 'accommodation';
              if (!vendor) vendor = 'Hotel';
              console.log('[Category] Vendor-based: accommodation (hotel with booking keywords)');
            }
          }
        }
        
        // Additional content-based detection if still misc
        if (category === 'misc') {
          if (/\b(groceries|produce|fruit|vegetable|meat|dairy|bread|milk|supermarket)\b/i.test(fullText)) {
            category = 'kai';
          } else if (/\b(petrol|diesel|fuel|litre|pump|91|95|unleaded)\b/i.test(fullText)) {
            category = 'petrol';
          } else if (/\b(flower|floral|bouquet|wreath)\b/i.test(fullText)) {
            category = 'flowers';
          }
        }
        
        // Find vendor name if not found from known stores
        if (!vendor) {
          const skipPatterns = [/^\s*$/, /^[\d\s\-\.\:\/]+$/, /^tax\s*inv/i, /^invoice/i, /^receipt/i];
          for (const line of lines.slice(0, 8)) {
            const trimmed = line.trim();
            if (trimmed.length < 3 || trimmed.length > 50) continue;
            if (skipPatterns.some(p => p.test(trimmed))) continue;
            if ((trimmed.match(/\d/g) || []).length > trimmed.length * 0.5) continue;
            vendor = trimmed;
            break;
          }
        }
        if (!vendor) vendor = 'Receipt';
        
        // Find date (NZ format: DD/MM/YYYY)
        for (const line of lines) {
          const dateMatch = line.match(/(\d{1,2})[\/\-\.](\d{1,2})[\/\-\.](\d{2,4})/);
          if (dateMatch) {
            let day = parseInt(dateMatch[1]);
            let month = parseInt(dateMatch[2]);
            let year = dateMatch[3].length === 2 ? 2000 + parseInt(dateMatch[3]) : parseInt(dateMatch[3]);
            if (day > 12 && month <= 12) { /* DD/MM confirmed */ }
            else if (month > 12 && day <= 12) { [day, month] = [month, day]; }
            if (day >= 1 && day <= 31 && month >= 1 && month <= 12 && year >= 2020 && year <= 2030) {
              date = `${year}-${month.toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}`;
              break;
            }
          }
        }
        
        // Find time
        const timeMatch = allText.match(/\b(\d{1,2}):(\d{2})(?::(\d{2}))?(?:\s*(am|pm))?\b/i);
        if (timeMatch) {
          let hour = parseInt(timeMatch[1]);
          if (timeMatch[4]?.toLowerCase() === 'pm' && hour < 12) hour += 12;
          if (timeMatch[4]?.toLowerCase() === 'am' && hour === 12) hour = 0;
          if (hour >= 0 && hour <= 23) {
            time = `${hour.toString().padStart(2, '0')}:${timeMatch[2]}`;
          }
        }
        
        // Payment method
        if (allText.includes('visa')) paymentMethod = 'Visa';
        else if (allText.includes('mastercard') || allText.includes('master card')) paymentMethod = 'Mastercard';
        else if (allText.includes('paywave') || allText.includes('contactless')) paymentMethod = 'Paywave';
        else if (allText.includes('eftpos')) paymentMethod = 'EFTPOS';
        else if (allText.includes('debit')) paymentMethod = 'Debit Card';
        else if (allText.includes('credit')) paymentMethod = 'Credit Card';
        else if (tendered > 0 || (allText.includes('cash') && change > 0)) paymentMethod = 'Cash';
        
        const cardMatch = allText.match(/[*xX]{4}\s*(\d{4})/);
        if (cardMatch) cardLastFour = cardMatch[1];
        
        // Extract items
        for (let i = Math.floor(lines.length * 0.1); i < Math.floor(lines.length * 0.75); i++) {
          const line = lines[i];
          if (/total|subtotal|gst|tax|eftpos|paid|change|tender|cash|balance/i.test(line)) continue;
          const itemMatch = line.match(/^(.{3,35}?)\s+\$?\s*(\d{1,3})[.,](\d{2})\s*$/);
          if (itemMatch) {
            const price = parseFloat(itemMatch[2] + '.' + itemMatch[3]);
            if (price > 0 && price < (total || 1000)) {
              items.push({ name: itemMatch[1].trim(), price });
            }
          }
        }
        
        return { total, vendor, date, time, category, items, subtotal: subtotal || null, gst: gst || null, discount: discount || null, cashOut: cashOut || null, change: change || null, paymentMethod: paymentMethod || null, cardLastFour: cardLastFour || null };
      };

      // Calculated values
      const totals = useMemo(() => {
        const giftsCash = gifts.filter(g => g.method === 'cash').reduce((a, g) => a + g.amount, 0);
        const giftsBank = gifts.filter(g => g.method === 'bank').reduce((a, g) => a + g.amount, 0);
        const expensesCash = expenses.filter(e => e.method === 'cash').reduce((a, e) => a + e.amount, 0);
        const expensesBank = expenses.filter(e => e.method === 'bank').reduce((a, e) => a + e.amount, 0);
        const transferredToBank = transfers.reduce((a, t) => a + t.amount, 0);
        
        return {
          giftsTotal: giftsCash + giftsBank,
          giftsCash, giftsBank,
          expensesTotal: expensesCash + expensesBank,
          expensesCash, expensesBank,
          transferredToBank,
          balanceCash: giftsCash - expensesCash - transferredToBank,
          balanceBank: giftsBank - expensesBank + transferredToBank,
          balanceTotal: (giftsCash + giftsBank) - (expensesCash + expensesBank)
        };
      }, [gifts, expenses, transfers]);

      // Unique donors for autocomplete
      const donors = useMemo(() => [...new Set(gifts.map(g => g.donor))].sort(), [gifts]);

      // Flagged expenses (incorrect categories)
      const flaggedExpenses = useMemo(() => {
        return expenses.filter(e => {
          const result = validationResults[e.id];
          return result && !result.correct && !result.dismissed && !result.applied;
        });
      }, [expenses, validationResults]);

      // Flagged gifts (incorrect categories)
      const flaggedGifts = useMemo(() => {
        return gifts.filter(g => {
          const result = giftValidationResults[g.id];
          return result && !result.correct && !result.dismissed && !result.applied;
        });
      }, [gifts, giftValidationResults]);

      // CRUD operations
      const addGift = (gift) => setGifts(prev => [...prev, { ...gift, id: Date.now(), createdAt: new Date().toISOString() }]);
      const addExpense = (expense) => setExpenses(prev => [...prev, { ...expense, id: Date.now(), createdAt: new Date().toISOString() }]);
      const addTransfer = (transfer) => setTransfers(prev => [...prev, { ...transfer, id: Date.now(), createdAt: new Date().toISOString() }]);
      const deleteGift = (id) => setGifts(prev => prev.filter(g => g.id !== id));
      const deleteExpense = (id) => setExpenses(prev => prev.filter(e => e.id !== id));
      const deleteTransfer = (id) => setTransfers(prev => prev.filter(t => t.id !== id));
      const updateGift = (id, updates) => setGifts(prev => prev.map(g => g.id === id ? { ...g, ...updates } : g));
      const updateExpense = (id, updates) => setExpenses(prev => prev.map(e => e.id === id ? { ...e, ...updates } : e));

      // Category Language Selector Component
      const CatLangSelector = ({ showLabel = true }) => {
        const [showMenu, setShowMenu] = useState(false);
        const options = [
          { code: 'all', label: 'All Languages', short: 'üåè' },
          { code: 'sm', label: 'Gagana Samoa', short: 'üáºüá∏' },
          { code: 'mi', label: 'Te Reo MƒÅori', short: 'üá≥üáø' },
          { code: 'en', label: 'English', short: 'üá¨üáß' }
        ];
        const current = options.find(o => o.code === catLang);
        
        return (
          <div className="relative">
            <button onClick={() => setShowMenu(!showMenu)} className="flex items-center gap-1 px-2 py-1 bg-slate-800 rounded-lg text-xs">
              <span>{current?.short}</span>
              {showLabel && <span className="text-slate-400 uppercase">{catLang === 'all' ? 'ALL' : catLang}</span>}
            </button>
            {showMenu && (
              <>
                <div className="fixed inset-0 z-40" onClick={() => setShowMenu(false)} />
                <div className="absolute right-0 top-full mt-1 bg-slate-800 rounded-xl overflow-hidden z-50 border border-slate-700 min-w-[160px]">
                  {options.map(o => (
                    <button key={o.code} onClick={() => { setCatLang(o.code); setShowMenu(false); }} className={`w-full px-4 py-3 text-left flex items-center gap-3 ${catLang === o.code ? 'bg-cyan-600' : 'hover:bg-slate-700 active:bg-slate-600'}`}>
                      <span>{o.short}</span>
                      <span className="text-white text-sm">{o.label}</span>
                    </button>
                  ))}
                </div>
              </>
            )}
          </div>
        );
      };

      // Navigation
      const Nav = () => (
        <div className="fixed bottom-0 left-0 right-0 bg-slate-900/95 backdrop-blur border-t border-slate-800 px-4 py-2 pb-6">
          <div className="flex justify-around max-w-md mx-auto">
            {[
              { id: 'home', icon: 'üè†', label: 'Fale' },
              { id: 'gifts', icon: 'üéÅ', label: 'Koha' },
              { id: 'expenses', icon: 'üí∏', label: 'Tau' },
              { id: 'analytics', icon: 'üìä', label: 'Aotelega' }
            ].map(n => (
              <button
                key={n.id}
                onClick={() => setScreen(n.id)}
                className={`flex flex-col items-center gap-1 px-4 py-1 rounded-xl transition-colors relative ${
                  screen === n.id || 
                  (n.id === 'gifts' && ['addGift', 'editGift'].includes(screen)) ||
                  (n.id === 'expenses' && ['addExpense', 'editExpense', 'addTransfer'].includes(screen))
                    ? 'text-cyan-400' : 'text-slate-500'
                }`}
              >
                <span className="text-xl">{n.icon}</span>
                <span className="text-xs">{n.label}</span>
                {n.id === 'analytics' && (flaggedExpenses.length + flaggedGifts.length) > 0 && (
                  <span className="absolute -top-1 -right-1 w-5 h-5 bg-red-500 rounded-full text-xs text-white flex items-center justify-center">
                    {flaggedExpenses.length + flaggedGifts.length}
                  </span>
                )}
              </button>
            ))}
          </div>
        </div>
      );

      // Home Screen
      const Home = () => {
        const recentTransactions = useMemo(() => {
          const all = [
            ...gifts.map(g => ({ ...g, type: 'gift' })),
            ...expenses.map(e => ({ ...e, type: 'expense' })),
            ...transfers.map(t => ({ ...t, type: 'transfer' }))
          ];
          return all.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt)).slice(0, 5);
        }, [gifts, expenses, transfers]);

        return (
          <div className="min-h-screen bg-slate-950 text-white pb-24">
            <div className="px-5 pt-8">
              <div className="flex justify-between items-start mb-4">
                <div>
                  <p className="text-slate-500 text-sm">ƒÄiga ‚Ä¢ WhƒÅnau ‚Ä¢ Family</p>
                  <h1 className="text-2xl font-bold">Meaalofa ‚Ä¢ Koha Tracker</h1>
                </div>
                <button onClick={() => setScreen('sync')} className="flex items-center gap-2 px-3 py-1.5 bg-slate-800 rounded-lg text-sm">
                  {syncing ? <span className="spin">üîÑ</span> : syncBinId ? <span className="text-green-400">‚òÅÔ∏è</span> : <span className="text-slate-500">‚òÅÔ∏è</span>}
                  <span className="text-slate-400">{syncBinId || 'Sync'}</span>
                </button>
              </div>

              {(isValidating || validationStatus) && (
                <ProgressBar progress={validationProgress} status={validationStatus} details={validationDetails} />
              )}

              {(flaggedExpenses.length > 0 || flaggedGifts.length > 0) && !isValidating && (
                <button onClick={() => setScreen('analytics')} className="w-full bg-amber-900/30 border border-amber-700/50 rounded-xl p-3 mb-4 flex items-center justify-between">
                  <div className="flex items-center gap-2">
                    <span className="text-amber-400">‚ö†Ô∏è</span>
                    <span className="text-amber-200 text-sm">{flaggedExpenses.length + flaggedGifts.length} item{(flaggedExpenses.length + flaggedGifts.length) !== 1 ? 's' : ''} may need review</span>
                  </div>
                  <span className="text-amber-400 text-sm">View ‚Üí</span>
                </button>
              )}

              <div className="bg-gradient-to-br from-cyan-600 to-teal-600 rounded-2xl p-5 mb-4">
                <p className="text-cyan-100 text-sm mb-1">Tupe Totoe ‚Ä¢ Toenga ‚Ä¢ Balance</p>
                <p className={`text-4xl font-bold ${totals.balanceTotal < 0 ? 'text-red-200' : 'text-white'}`}>{fmt(totals.balanceTotal)}</p>
                <div className="flex gap-6 mt-4">
                  <div>
                    <p className="text-cyan-100 text-xs">Tipi ‚Ä¢ Moni ‚Ä¢ Cash</p>
                    <p className={`text-lg font-semibold ${totals.balanceCash < 0 ? 'text-red-200' : 'text-white'}`}>{fmt(totals.balanceCash)}</p>
                  </div>
                  <div>
                    <p className="text-cyan-100 text-xs">Faletupe ‚Ä¢ Pƒìke ‚Ä¢ Bank</p>
                    <p className={`text-lg font-semibold ${totals.balanceBank < 0 ? 'text-red-200' : 'text-white'}`}>{fmt(totals.balanceBank)}</p>
                  </div>
                </div>
                {totals.balanceCash > 0 && (
                  <button onClick={() => setScreen('addTransfer')} className="mt-4 w-full py-2 bg-white/20 rounded-xl text-sm font-medium flex items-center justify-center gap-2">
                    üíµ ‚Üí üè¶ Tupe i le Faletupe ‚Ä¢ Deposit Cash
                  </button>
                )}
              </div>

              <div className="grid grid-cols-2 gap-3 mb-6">
                <div className="bg-slate-900 rounded-xl p-4">
                  <div className="flex items-center gap-2 mb-1">
                    <span className="text-green-400">‚Üì</span>
                    <span className="text-slate-400 text-sm">Maua ‚Ä¢ Whiwhi ‚Ä¢ In</span>
                  </div>
                  <p className="text-2xl font-bold text-green-400">{fmt(totals.giftsTotal)}</p>
                  <p className="text-slate-500 text-xs mt-1">{gifts.length} meaalofa ‚Ä¢ koha</p>
                </div>
                <div className="bg-slate-900 rounded-xl p-4">
                  <div className="flex items-center gap-2 mb-1">
                    <span className="text-red-400">‚Üë</span>
                    <span className="text-slate-400 text-sm">Fa'aalu ‚Ä¢ Utu ‚Ä¢ Out</span>
                  </div>
                  <p className="text-2xl font-bold text-red-400">{fmt(totals.expensesTotal)}</p>
                  <p className="text-slate-500 text-xs mt-1">{expenses.length} tau ‚Ä¢ utu</p>
                </div>
              </div>

              <div className="grid grid-cols-2 gap-3 mb-6">
                <button onClick={() => setScreen('addGift')} className="bg-gradient-to-br from-green-600 to-emerald-600 rounded-xl p-4 text-left active:scale-95 transition-transform">
                  <span className="text-2xl">üéÅ</span>
                  <p className="font-bold mt-2">Fa'aopopo Meaalofa</p>
                  <p className="text-green-100 text-xs">TƒÅpiri Koha ‚Ä¢ Add Gift</p>
                </button>
                <button onClick={() => setScreen('addExpense')} className="bg-gradient-to-br from-orange-600 to-red-600 rounded-xl p-4 text-left active:scale-95 transition-transform">
                  <span className="text-2xl">üí∏</span>
                  <p className="font-bold mt-2">Fa'aopopo Tau</p>
                  <p className="text-orange-100 text-xs">TƒÅpiri Utu ‚Ä¢ Add Expense</p>
                </button>
              </div>

              {recentTransactions.length > 0 && (
                <div>
                  <p className="text-slate-400 text-sm font-medium mb-3">TALU AI NEI ‚Ä¢ RECENT</p>
                  <div className="space-y-2">
                    {recentTransactions.map(tx => {
                      const giftCat = tx.type === 'gift' ? getGiftCategoryById(tx.category) : null;
                      return (
                        <div key={tx.id} onClick={() => { if (tx.type !== 'transfer') { setEditingItem(tx); setScreen(tx.type === 'gift' ? 'editGift' : 'editExpense'); }}} className={`bg-slate-900 rounded-xl p-3 flex items-center gap-3 ${tx.type !== 'transfer' ? 'active:bg-slate-800' : ''}`}>
                          <div className={`w-10 h-10 rounded-full flex items-center justify-center`} style={tx.type === 'gift' && giftCat ? { backgroundColor: giftCat.color + '30' } : {}}>
                            <span>{tx.type === 'gift' ? (giftCat?.icon || 'üéÅ') : tx.type === 'transfer' ? 'üè¶' : getCategoryById(tx.category).icon}</span>
                          </div>
                          <div className="flex-1">
                            <p className="font-medium text-white">{tx.type === 'gift' ? tx.donor : tx.type === 'transfer' ? 'Cash ‚Üí Bank' : tx.description || getCategoryName(getCategoryById(tx.category))}</p>
                            <p className="text-slate-500 text-xs">{fmtDate(tx.date)} ‚Ä¢ {tx.type === 'transfer' ? 'üíµ‚Üíüè¶' : tx.method === 'cash' ? 'üíµ' : 'üè¶'}</p>
                          </div>
                          <div className="text-right">
                            <p className={`font-bold ${tx.type === 'gift' ? 'text-green-400' : tx.type === 'transfer' ? 'text-blue-400' : 'text-red-400'}`}>
                              {tx.type === 'gift' ? '+' : tx.type === 'transfer' ? '' : '-'}{fmt(tx.amount)}
                            </p>
                            {tx.type === 'expense' && validationResults[tx.id] && !validationResults[tx.id].correct && !validationResults[tx.id].dismissed && (
                              <span className="text-amber-400 text-xs">‚ö†Ô∏è</span>
                            )}
                          </div>
                        </div>
                      );
                    })}
                  </div>
                </div>
              )}
            </div>
            <Nav />
          </div>
        );
      };

      // Analytics Screen (abbreviated for space - keeping essential validation tab)
      const Analytics = () => {
        const [tab, setTab] = useState('overview');
        const [selectedCategory, setSelectedCategory] = useState(null);

        const expensesByGroup = useMemo(() => {
          const groups = {};
          expenses.forEach(e => {
            const cat = getCategoryById(e.category);
            const group = cat.group;
            groups[group] = (groups[group] || 0) + e.amount;
          });
          return Object.entries(CATEGORY_GROUPS).map(([id, info]) => ({
            id, label: info.name.split(' ‚Ä¢ ').pop(), value: groups[id] || 0, color: info.color
          })).filter(g => g.value > 0);
        }, [expenses]);

        const expensesByCategory = useMemo(() => {
          const cats = {};
          expenses.forEach(e => { cats[e.category] = (cats[e.category] || 0) + e.amount; });
          return Object.entries(cats).map(([id, value]) => {
            const cat = getCategoryById(id);
            const group = CATEGORY_GROUPS[cat.group];
            const colorIndex = EXPENSE_CATEGORIES.filter(c => c.group === cat.group).findIndex(c => c.id === id);
            return { id, label: cat.en, icon: cat.icon, value, color: group.colors[colorIndex % group.colors.length] };
          }).sort((a, b) => b.value - a.value);
        }, [expenses]);

        const cashFlowData = useMemo(() => [
          { label: 'Koha In', value: totals.giftsTotal, color: '#22c55e' },
          { label: 'Expenses Out', value: totals.expensesTotal, color: '#ef4444' }
        ], [totals]);

        const giftsByMethod = useMemo(() => [
          { label: 'Cash', value: totals.giftsCash, color: '#22c55e' },
          { label: 'Bank', value: totals.giftsBank, color: '#3b82f6' }
        ], [totals]);

        const giftsByCategory = useMemo(() => {
          const cats = {};
          gifts.forEach(g => { const catId = g.category || 'isi'; cats[catId] = (cats[catId] || 0) + g.amount; });
          return GIFT_CATEGORIES.map(cat => ({ id: cat.id, label: cat.en, icon: cat.icon, value: cats[cat.id] || 0, color: cat.color })).filter(c => c.value > 0);
        }, [gifts]);

        const timelineData = useMemo(() => {
          const all = [...gifts.map(g => ({ ...g, type: 'gift' })), ...expenses.map(e => ({ ...e, type: 'expense' })), ...transfers.map(t => ({ ...t, type: 'transfer' }))].sort((a, b) => new Date(a.date) - new Date(b.date));
          const byDate = {};
          all.forEach(item => {
            const date = item.date;
            if (!byDate[date]) byDate[date] = { date, gifts: 0, expenses: 0, transfers: 0, items: [] };
            if (item.type === 'gift') byDate[date].gifts += item.amount;
            else if (item.type === 'expense') byDate[date].expenses += item.amount;
            else byDate[date].transfers += item.amount;
            byDate[date].items.push(item);
          });
          return Object.values(byDate);
        }, [gifts, expenses, transfers]);

        const donorRankings = useMemo(() => {
          const totals = {};
          gifts.forEach(g => { totals[g.donor] = (totals[g.donor] || 0) + g.amount; });
          return Object.entries(totals).sort((a, b) => b[1] - a[1]);
        }, [gifts]);

        return (
          <div className="min-h-screen bg-slate-950 text-white pb-24">
            <div className="px-5 pt-8">
              <div className="flex justify-between items-center mb-4">
                <h1 className="text-2xl font-bold">Aotelega ‚Ä¢ Summary</h1>
                <CatLangSelector showLabel={false} />
              </div>

              {(isValidating || validationStatus) && <ProgressBar progress={validationProgress} status={validationStatus} details={validationDetails} />}

              <div className="flex gap-2 mb-6 overflow-x-auto pb-2">
                {[
                  { id: 'overview', label: 'üìä Overview' },
                  { id: 'validation', label: `‚ö†Ô∏è Review${(flaggedExpenses.length + flaggedGifts.length) ? ` (${flaggedExpenses.length + flaggedGifts.length})` : ''}` },
                  { id: 'timeline', label: 'üìÖ Timeline' },
                  { id: 'donors', label: 'üéÅ Donors' }
                ].map(t => (
                  <button key={t.id} onClick={() => setTab(t.id)} className={`px-4 py-2 rounded-lg text-sm font-medium whitespace-nowrap ${tab === t.id ? 'bg-cyan-600 text-white' : 'bg-slate-900 text-slate-400'}`}>{t.label}</button>
                ))}
              </div>

              {tab === 'overview' && (
                <div className="space-y-6">
                  <div className="bg-gradient-to-br from-slate-800 to-slate-900 rounded-xl p-4 border border-slate-700">
                    <div className="grid grid-cols-3 gap-4 text-center">
                      <div><p className="text-slate-500 text-xs">In</p><p className="text-green-400 font-bold text-lg">{fmt(totals.giftsTotal)}</p></div>
                      <div><p className="text-slate-500 text-xs">Out</p><p className="text-red-400 font-bold text-lg">{fmt(totals.expensesTotal)}</p></div>
                      <div><p className="text-slate-500 text-xs">Balance</p><p className={`font-bold text-lg ${totals.balanceTotal < 0 ? 'text-red-400' : 'text-cyan-400'}`}>{fmt(totals.balanceTotal)}</p></div>
                    </div>
                  </div>
                  <div className="bg-slate-900 rounded-xl p-4"><PieChart data={cashFlowData} size={180} title="üí∞ CASH FLOW" /></div>
                  {expensesByGroup.length > 0 && <div className="bg-slate-900 rounded-xl p-4"><PieChart data={expensesByGroup} size={180} title="üìä EXPENSES BY TYPE" /></div>}
                  {totals.giftsTotal > 0 && <div className="bg-slate-900 rounded-xl p-4"><PieChart data={giftsByMethod} size={180} title="üéÅ KOHA BY METHOD" /></div>}
                  {giftsByCategory.length > 0 && <div className="bg-slate-900 rounded-xl p-4"><PieChart data={giftsByCategory} size={180} title="üéÅ KOHA BY SOURCE" /></div>}
                </div>
              )}

              {tab === 'validation' && (
                <div className="space-y-4">
                  <div className="bg-slate-900 rounded-xl p-4">
                    <p className="text-slate-400 text-sm font-medium mb-3">ü§ñ AI VALIDATION</p>
                    <div className="grid grid-cols-2 gap-2 mb-2">
                      <button onClick={(e) => { e.stopPropagation(); validateExpenses(expenses, false, false); }} disabled={isValidating} className="py-3 bg-slate-800 rounded-xl text-sm font-medium disabled:opacity-50">{isValidating ? 'üîÑ Running...' : '‚ö° Quick Scan'}</button>
                      <button onClick={(e) => { e.stopPropagation(); validateExpenses(expenses, true, true); }} disabled={isValidating} className="py-3 bg-gradient-to-r from-purple-600 to-pink-600 rounded-xl text-sm font-medium disabled:opacity-50">{isValidating ? 'üîÑ Running...' : 'ü§ñ Deep AI Scan'}</button>
                    </div>
                    <p className="text-slate-600 text-xs">Quick scan: expenses only (keywords). Deep scan: expenses + koha (AI powered).</p>
                  </div>

                  {flaggedExpenses.length > 0 && (
                    <div className="bg-slate-900 rounded-xl p-4">
                      <p className="text-amber-400 text-sm font-medium mb-3">‚ö†Ô∏è EXPENSES TO REVIEW ({flaggedExpenses.length})</p>
                      <div className="space-y-3">
                        {flaggedExpenses.map(expense => {
                          const cat = getCategoryById(expense.category);
                          const result = validationResults[expense.id];
                          const suggestedCat = result.suggestedId ? getCategoryById(result.suggestedId) : null;
                          return (
                            <div key={expense.id} className="bg-slate-800 rounded-xl p-3 slide-in">
                              <div className="flex items-start justify-between mb-2">
                                <div><p className="text-white font-medium">{expense.description || cat.en}</p><p className="text-slate-500 text-xs">{fmtDateFull(expense.date)} ‚Ä¢ {fmt(expense.amount)}</p></div>
                                <span className="text-amber-400 bg-amber-400/20 px-2 py-1 rounded text-xs">{result.confidence || result.aiConfidence}%</span>
                              </div>
                              <div className="flex items-center gap-2 mb-2 text-sm flex-wrap">
                                <span className="flex items-center gap-1 text-white">{cat.icon} {cat.en}</span>
                                <span className="text-slate-600">‚Üí</span>
                                <span className="flex items-center gap-1 text-cyan-400">{suggestedCat?.icon} {result.suggested || result.aiSuggested}</span>
                              </div>
                              <p className="text-slate-500 text-xs mb-3">{result.reason || result.aiReason}</p>
                              <div className="flex gap-2">
                                <button onClick={(e) => { e.stopPropagation(); if (result.suggestedId) applySuggestion(expense.id, result.suggestedId); }} disabled={!result.suggestedId} className="flex-1 py-2 bg-green-600 rounded-lg text-sm font-medium disabled:opacity-50">‚úì Apply</button>
                                <button onClick={(e) => { e.stopPropagation(); dismissSuggestion(expense.id); }} className="flex-1 py-2 bg-slate-700 rounded-lg text-sm font-medium">‚úï Keep</button>
                              </div>
                            </div>
                          );
                        })}
                      </div>
                    </div>
                  )}

                  {flaggedGifts.length > 0 && (
                    <div className="bg-slate-900 rounded-xl p-4">
                      <p className="text-pink-400 text-sm font-medium mb-3">üéÅ KOHA TO REVIEW ({flaggedGifts.length})</p>
                      <div className="space-y-3">
                        {flaggedGifts.map(gift => {
                          const cat = getGiftCategoryById(gift.category);
                          const result = giftValidationResults[gift.id];
                          const suggestedCat = result.suggestedId ? getGiftCategoryById(result.suggestedId) : null;
                          return (
                            <div key={gift.id} className="bg-slate-800 rounded-xl p-3 slide-in">
                              <div className="flex items-start justify-between mb-2">
                                <div><p className="text-white font-medium">{gift.donor}</p><p className="text-slate-500 text-xs">{fmtDateFull(gift.date)} ‚Ä¢ {fmt(gift.amount)}</p></div>
                                <span className="text-pink-400 bg-pink-400/20 px-2 py-1 rounded text-xs">{result.confidence || result.aiConfidence}%</span>
                              </div>
                              <div className="flex items-center gap-2 mb-2 text-sm flex-wrap">
                                <span className="flex items-center gap-1 text-white">{cat.icon} {cat.en}</span>
                                <span className="text-slate-600">‚Üí</span>
                                <span className="flex items-center gap-1" style={{ color: suggestedCat?.color || '#06b6d4' }}>{suggestedCat?.icon} {result.suggested || result.aiSuggested}</span>
                              </div>
                              <p className="text-slate-500 text-xs mb-3">{result.reason || result.aiReason}</p>
                              <div className="flex gap-2">
                                <button onClick={(e) => { e.stopPropagation(); if (result.suggestedId) applyGiftSuggestion(gift.id, result.suggestedId); }} disabled={!result.suggestedId} className="flex-1 py-2 bg-green-600 rounded-lg text-sm font-medium disabled:opacity-50">‚úì Apply</button>
                                <button onClick={(e) => { e.stopPropagation(); dismissGiftSuggestion(gift.id); }} className="flex-1 py-2 bg-slate-700 rounded-lg text-sm font-medium">‚úï Keep</button>
                              </div>
                            </div>
                          );
                        })}
                      </div>
                    </div>
                  )}

                  {flaggedExpenses.length === 0 && flaggedGifts.length === 0 && Object.keys(validationResults).length > 0 && (
                    <div className="bg-green-900/30 border border-green-700/50 rounded-xl p-6 text-center">
                      <span className="text-4xl mb-2 block">‚úÖ</span>
                      <p className="text-green-400 font-medium">All categories look correct!</p>
                    </div>
                  )}
                </div>
              )}

              {tab === 'timeline' && (
                <div className="space-y-3">
                  {timelineData.length > 0 ? timelineData.map(day => (
                    <div key={day.date} className="bg-slate-900 rounded-xl p-4">
                      <div className="flex justify-between items-center mb-3">
                        <p className="text-white font-medium">{fmtDateFull(day.date)}</p>
                        <div className="flex gap-3 text-sm">
                          {day.gifts > 0 && <span className="text-green-400">+{fmt(day.gifts)}</span>}
                          {day.expenses > 0 && <span className="text-red-400">-{fmt(day.expenses)}</span>}
                        </div>
                      </div>
                      <div className="space-y-2">
                        {day.items.map(item => {
                          const cat = item.type === 'expense' ? getCategoryById(item.category) : null;
                          return (
                            <div key={item.id} className="flex items-center gap-3 text-sm">
                              <span className="w-6 text-center">{item.type === 'gift' ? 'üéÅ' : item.type === 'transfer' ? 'üè¶' : cat?.icon}</span>
                              <span className="flex-1 text-slate-300">{item.type === 'gift' ? item.donor : item.type === 'transfer' ? 'Cash ‚Üí Bank' : item.description || cat?.en}</span>
                              <span className={item.type === 'gift' ? 'text-green-400' : item.type === 'transfer' ? 'text-blue-400' : 'text-red-400'}>{item.type === 'gift' ? '+' : item.type === 'expense' ? '-' : ''}{fmt(item.amount)}</span>
                            </div>
                          );
                        })}
                      </div>
                    </div>
                  )) : <div className="text-center py-12"><span className="text-4xl mb-4 block">üìÖ</span><p className="text-slate-400">No transactions yet</p></div>}
                </div>
              )}

              {tab === 'donors' && (
                <div className="space-y-3">
                  {donorRankings.length > 0 ? (
                    <div className="bg-slate-900 rounded-xl p-4">
                      <p className="text-slate-400 text-sm font-medium mb-3">ALL DONORS ({donorRankings.length})</p>
                      <div className="space-y-2 max-h-80 overflow-y-auto">
                        {donorRankings.map(([donor, amount], i) => (
                          <div key={donor} className="flex justify-between items-center py-2 border-b border-slate-800 last:border-0">
                            <div className="flex items-center gap-3">
                              <span className={`w-6 h-6 rounded-full flex items-center justify-center text-xs ${i < 3 ? 'bg-amber-500/20 text-amber-400' : 'bg-slate-800 text-slate-500'}`}>{i + 1}</span>
                              <span className="text-white">{donor}</span>
                            </div>
                            <span className="text-green-400 font-medium">{fmt(amount)}</span>
                          </div>
                        ))}
                      </div>
                    </div>
                  ) : <div className="text-center py-12"><span className="text-4xl mb-4 block">üéÅ</span><p className="text-slate-400">No koha recorded yet</p></div>}
                </div>
              )}

              <button onClick={() => { if (confirm('Delete ALL data?')) { if (confirm('Really?')) { setGifts([]); setExpenses([]); setTransfers([]); setSyncCode(null); setSyncBinId(null); setLastSync(null); setValidationResults({}); setGiftValidationResults({}); setScreen('home'); }}}} className="w-full py-3 bg-red-900/30 border border-red-900/50 rounded-xl text-red-400 text-sm mt-6">Tape Data Uma ‚Ä¢ Reset All</button>
            </div>
            <Nav />
          </div>
        );
      };

      // Sync Screen
      const SyncScreen = () => {
        const [joinCode, setJoinCode] = useState('');
        const [importCode, setImportCode] = useState('');
        const [copied, setCopied] = useState(false);
        const [error, setError] = useState('');
        const [status, setStatus] = useState('');
        const [creating, setCreating] = useState(false);
        const [debugLog, setDebugLog] = useState('');
        const [exportedCode, setExportedCode] = useState('');
        
        const log = (msg) => { const timestamp = new Date().toLocaleTimeString(); setDebugLog(prev => prev + '\n[' + timestamp + '] ' + msg); console.log(msg); };

        const handleCreateSync = async () => {
          setDebugLog('--- Starting Create Sync ---'); log('Step 1: Button clicked');
          setError(''); setStatus('üîÑ Creating family sync...'); setCreating(true);
          try {
            log('Step 2: Calling CloudSync.create...');
            const result = await CloudSync.create({ gifts, expenses, transfers });
            log('Step 3: CloudSync.create returned: ' + JSON.stringify(result));
            if (result && typeof result === 'string') {
              setSyncCode(result); setSyncBinId(result); setLastSync(Date.now()); setStatus('‚úÖ Created!');
              log('Step 4: SUCCESS! Code: ' + result);
            } else if (result && result.error) {
              setStatus(''); setError('API Error: ' + result.error);
            } else { setStatus(''); setError('Cloud sync failed - unknown error'); }
          } catch (e) { log('ERROR: ' + (e.message || String(e))); setStatus(''); setError('Error: ' + (e.message || String(e))); }
          setCreating(false); log('--- Finished ---');
        };

        const copyFamilyCode = async () => {
          const success = await copyToClipboard(syncBinId);
          if (success) { setCopied(true); setTimeout(() => setCopied(false), 2000); }
          else { alert('Copy failed. Code is: ' + syncBinId); }
        };

        const handleJoinSync = async () => {
          const code = joinCode.trim().toUpperCase();
          if (code.length < 4 || code.length > 6) { alert('Please enter the 5-letter family code'); return; }
          setSyncing(true);
          const data = await CloudSync.get(code);
          setSyncing(false);
          if (data) {
            setSyncCode(code); setSyncBinId(code);
            const mergeArrays = (local, cloud) => { const map = new Map(); [...local, ...(cloud || [])].forEach(item => map.set(item.id, item)); return Array.from(map.values()); };
            setGifts(mergeArrays(gifts, data.gifts || []));
            setExpenses(mergeArrays(expenses, data.expenses || []));
            setTransfers(mergeArrays(transfers, data.transfers || []));
            setLastSync(Date.now());
            alert('‚úÖ Connected! Data synced.'); setJoinCode('');
          } else { alert('Code not found. Check the code and try again.'); }
        };

        const handleExport = async () => {
          const data = { gifts, expenses, transfers, exportedAt: Date.now(), version: 2 };
          const encoded = btoa(unescape(encodeURIComponent(JSON.stringify(data))));
          setExportedCode(encoded);
          const success = await copyToClipboard(encoded);
          if (success) { setCopied(true); setTimeout(() => setCopied(false), 2000); }
        };

        const handleImport = () => {
          try {
            const decoded = JSON.parse(decodeURIComponent(escape(atob(importCode.trim()))));
            if (decoded.gifts || decoded.expenses) {
              const mergeArrays = (local, imported) => { const map = new Map(); [...local, ...(imported || [])].forEach(item => map.set(item.id, item)); return Array.from(map.values()); };
              setGifts(mergeArrays(gifts, decoded.gifts));
              setExpenses(mergeArrays(expenses, decoded.expenses));
              setTransfers(mergeArrays(transfers, decoded.transfers));
              alert(`‚úÖ Imported!\n${decoded.gifts?.length || 0} gifts\n${decoded.expenses?.length || 0} expenses`);
              setImportCode('');
            } else { alert('Invalid backup code'); }
          } catch (e) { alert('Invalid code. Make sure you copied the whole backup code.'); }
        };

        return (
          <div className="min-h-screen bg-slate-950 text-white pb-24">
            <div className="px-5 pt-8">
              <button onClick={() => setScreen('home')} className="text-slate-500 text-sm mb-4">‚Üê Back</button>
              <h1 className="text-2xl font-bold mb-2">Fa'atasi ‚Ä¢ Sync</h1>
              <p className="text-slate-500 text-sm mb-6">Share with whƒÅnau</p>

              {error && <div className="bg-red-900/30 border border-red-700/50 rounded-xl p-3 mb-4"><p className="text-red-300 text-sm">{error}</p></div>}
              {status && <div className="bg-cyan-900/30 border border-cyan-700/50 rounded-xl p-3 mb-4"><p className="text-cyan-300 text-sm">{status}</p></div>}

              <div className={`rounded-xl p-4 mb-6 ${syncBinId ? 'bg-green-900/30 border border-green-700/50' : 'bg-slate-900'}`}>
                <div className="flex items-center gap-3">
                  <span className="text-2xl">{syncBinId ? '‚òÅÔ∏è' : 'üì¥'}</span>
                  <div className="flex-1">
                    <p className="font-medium">{syncBinId ? 'Family Sync Active' : 'Not Connected'}</p>
                    {syncBinId ? <p className="text-green-400 text-xl font-bold tracking-widest">{syncBinId}</p> : <p className="text-slate-500 text-sm">Create or join below</p>}
                  </div>
                </div>
              </div>

              {syncBinId ? (
                <>
                  <button onClick={copyFamilyCode} className="w-full py-3 bg-cyan-600 rounded-xl font-medium mb-3">{copied ? '‚úì Copied!' : 'üìã Copy Family Code'}</button>
                  <p className="text-slate-500 text-xs text-center mb-4">Share this code with whƒÅnau to connect their devices</p>
                  <button onClick={syncFromCloud} disabled={syncing} className="w-full py-3 bg-slate-800 rounded-xl font-medium mb-3">{syncing ? 'üîÑ Syncing...' : 'üîÑ Sync Now'}</button>
                  <button onClick={() => { if (confirm('Leave Family Sync?')) { setSyncCode(null); setSyncBinId(null); }}} className="w-full py-3 bg-red-900/30 rounded-xl text-red-400 text-sm">üö™ Leave Family Sync</button>
                </>
              ) : (
                <div className="bg-slate-900 rounded-xl p-4 mb-4">
                  <p className="text-white font-medium mb-2">‚òÅÔ∏è Cloud Sync</p>
                  <p className="text-slate-500 text-xs mb-3">Auto-syncs between devices</p>
                  <button onClick={handleCreateSync} disabled={creating} className="w-full py-3 bg-gradient-to-r from-cyan-600 to-teal-600 rounded-xl font-bold disabled:opacity-50 mb-3">{creating ? 'üîÑ Creating...' : '+ Create Family Sync'}</button>
                  <div className="border-t border-slate-800 pt-3 mt-3">
                    <p className="text-slate-400 text-xs mb-2">Or join existing family:</p>
                    <input type="text" value={joinCode} onChange={(e) => setJoinCode(e.target.value.toUpperCase().slice(0, 5))} placeholder="Enter 5-letter code" className="w-full bg-slate-800 rounded-xl px-4 py-3 text-white mb-2 text-sm text-center tracking-widest font-bold uppercase" maxLength={5} />
                    <button onClick={handleJoinSync} disabled={!joinCode.trim() || syncing} className="w-full py-2 bg-slate-700 rounded-xl font-medium disabled:opacity-50">{syncing ? 'üîÑ Connecting...' : 'Join Family'}</button>
                  </div>
                </div>
              )}

              <div className="mt-6 pt-6 border-t border-slate-800">
                <p className="text-white font-medium mb-3">üì¶ Manual Backup</p>
                <button onClick={handleExport} className="w-full py-3 bg-purple-600 rounded-xl font-medium mb-2">{copied ? '‚úì Copied!' : `üì§ Export Data (${gifts.length} gifts, ${expenses.length} expenses)`}</button>
                {exportedCode && <textarea readOnly value={exportedCode} className="w-full bg-slate-800 rounded-xl px-3 py-2 text-xs text-slate-300 h-16 font-mono mb-1" onClick={(e) => e.target.select()} />}
                <div className="mt-3">
                  <input type="text" value={importCode} onChange={(e) => setImportCode(e.target.value)} placeholder="Paste backup code to import" className="w-full bg-slate-800 rounded-xl px-4 py-3 text-white mb-2 text-sm" />
                  <button onClick={handleImport} disabled={!importCode.trim()} className="w-full py-2 bg-slate-700 rounded-xl font-medium disabled:opacity-50">üì• Import Backup</button>
                </div>
              </div>

              {lastSync && <p className="text-slate-600 text-xs text-center mt-6">Last sync: {new Date(lastSync).toLocaleString()}</p>}
            </div>
            <Nav />
          </div>
        );
      };

      // Add Transfer Screen
      const AddTransfer = () => {
        const [amount, setAmount] = useState('');
        const [date, setDate] = useState(new Date().toISOString().split('T')[0]);
        const [note, setNote] = useState('');

        const handleSubmit = () => {
          if (!amount || parseFloat(amount) <= 0 || parseFloat(amount) > totals.balanceCash) return;
          addTransfer({ amount: parseFloat(amount), date, note: note.trim() });
          setScreen('home');
        };

        return (
          <div className="min-h-screen bg-slate-950 text-white pb-24">
            <div className="px-5 pt-8">
              <button onClick={() => setScreen('home')} className="text-slate-500 text-sm mb-4">‚Üê Back</button>
              <h1 className="text-2xl font-bold mb-6">üíµ ‚Üí üè¶ Deposit Cash</h1>
              <div className="bg-slate-900 rounded-xl p-4 mb-6">
                <p className="text-slate-400 text-sm">Cash Available</p>
                <p className="text-2xl font-bold text-green-400">{fmt(totals.balanceCash)}</p>
              </div>
              <div className="mb-4">
                <label className="text-slate-400 text-sm mb-2 block">Amount</label>
                <div className="relative">
                  <span className="absolute left-4 top-1/2 -translate-y-1/2 text-slate-400 text-xl">$</span>
                  <input type="number" value={amount} onChange={(e) => setAmount(e.target.value)} placeholder="0.00" className="w-full bg-slate-900 rounded-xl px-4 py-4 pl-10 text-2xl font-bold text-white placeholder-slate-600 outline-none" />
                </div>
                <button onClick={() => setAmount(totals.balanceCash.toString())} className="mt-2 text-cyan-400 text-sm">All ({fmt(totals.balanceCash)})</button>
              </div>
              <div className="mb-4">
                <label className="text-slate-400 text-sm mb-2 block">Date</label>
                <input type="date" value={date} onChange={(e) => setDate(e.target.value)} className="w-full bg-slate-900 rounded-xl px-4 py-3 text-white" />
              </div>
              <div className="mb-6">
                <label className="text-slate-400 text-sm mb-2 block">Note</label>
                <input type="text" value={note} onChange={(e) => setNote(e.target.value)} placeholder="(optional)" className="w-full bg-slate-900 rounded-xl px-4 py-3 text-white placeholder-slate-600" />
              </div>
              <button onClick={handleSubmit} disabled={!amount || parseFloat(amount) <= 0 || parseFloat(amount) > totals.balanceCash} className="w-full py-4 bg-gradient-to-r from-blue-600 to-cyan-600 rounded-xl font-bold text-lg disabled:opacity-50">Deposit</button>
            </div>
            <Nav />
          </div>
        );
      };

      // Add Gift Screen
      const AddGift = ({ editing = false }) => {
        const [amount, setAmount] = useState(editing && editingItem ? editingItem.amount.toString() : '');
        const [donor, setDonor] = useState(editing && editingItem ? editingItem.donor : '');
        const [category, setCategory] = useState(editing && editingItem ? editingItem.category || '' : '');
        const [method, setMethod] = useState(editing && editingItem ? editingItem.method : 'cash');
        const [note, setNote] = useState(editing && editingItem ? editingItem.note || '' : '');
        const [date, setDate] = useState(editing && editingItem ? editingItem.date : new Date().toISOString().split('T')[0]);
        const [showSuggestions, setShowSuggestions] = useState(false);
        const [showCategories, setShowCategories] = useState(false);
        const [confirmDelete, setConfirmDelete] = useState(false);
        const [aiSuggestion, setAiSuggestion] = useState(null);

        const filteredDonors = useMemo(() => {
          if (!donor.trim()) return [];
          return donors.filter(d => d.toLowerCase().includes(donor.toLowerCase()) && d.toLowerCase() !== donor.toLowerCase());
        }, [donor, donors]);

        useEffect(() => {
          if (donor.trim().length > 2) {
            const suggestion = AIValidator.suggestGiftCategory(donor, gifts);
            setAiSuggestion(suggestion);
            if (suggestion && !category && suggestion.confidence >= 75) setCategory(suggestion.categoryId);
          } else { setAiSuggestion(null); }
        }, [donor, gifts]);

        const handleSubmit = () => {
          if (!amount || !donor.trim()) return;
          const giftData = { amount: parseFloat(amount), donor: donor.trim(), category: category || 'isi', method, note: note.trim(), date };
          if (editing && editingItem) updateGift(editingItem.id, giftData);
          else addGift(giftData);
          setScreen('gifts'); setEditingItem(null);
        };

        const handleDelete = () => {
          if (confirmDelete) { deleteGift(editingItem.id); setScreen('gifts'); setEditingItem(null); }
          else { setConfirmDelete(true); setTimeout(() => setConfirmDelete(false), 3000); }
        };

        const selectedCat = category ? getGiftCategoryById(category) : null;

        return (
          <div className="min-h-screen bg-slate-950 text-white pb-24">
            <div className="px-5 pt-8">
              <button onClick={() => { setScreen(editing ? 'gifts' : 'home'); setEditingItem(null); }} className="text-slate-500 text-sm mb-4">‚Üê Back</button>
              <h1 className="text-2xl font-bold mb-6">{editing ? "Edit" : "Add Gift"}</h1>
              
              <div className="mb-4">
                <label className="text-slate-400 text-sm mb-2 block">Amount</label>
                <div className="relative">
                  <span className="absolute left-4 top-1/2 -translate-y-1/2 text-slate-400 text-xl">$</span>
                  <input type="number" value={amount} onChange={(e) => setAmount(e.target.value)} placeholder="0.00" className="w-full bg-slate-900 rounded-xl px-4 py-4 pl-10 text-2xl font-bold text-white placeholder-slate-600 outline-none" />
                </div>
              </div>
              
              <div className="mb-4 relative">
                <label className="text-slate-400 text-sm mb-2 block">From</label>
                <input type="text" value={donor} onChange={(e) => { setDonor(e.target.value); setShowSuggestions(true); }} onFocus={() => setShowSuggestions(true)} onBlur={() => setTimeout(() => setShowSuggestions(false), 200)} placeholder="Name" className="w-full bg-slate-900 rounded-xl px-4 py-3 text-white placeholder-slate-600 outline-none" />
                {showSuggestions && filteredDonors.length > 0 && (
                  <div className="absolute top-full left-0 right-0 mt-1 bg-slate-800 rounded-xl overflow-hidden z-10 border border-slate-700">
                    {filteredDonors.slice(0, 5).map(d => (<button key={d} onClick={() => { setDonor(d); setShowSuggestions(false); }} className="w-full px-4 py-3 text-left text-white hover:bg-slate-700">{d}</button>))}
                  </div>
                )}
              </div>

              {aiSuggestion && !category && (
                <div className="mb-4 bg-cyan-900/30 border border-cyan-700/50 rounded-xl p-3">
                  <div className="flex items-center justify-between mb-1">
                    <div className="flex items-center gap-2"><span>ü§ñ</span><span className="text-cyan-200 text-sm">Looks like {aiSuggestion.category.en}?</span></div>
                    <button onClick={() => setCategory(aiSuggestion.categoryId)} className="px-3 py-1 bg-cyan-600 rounded-lg text-sm font-medium">{aiSuggestion.category.icon} Yes</button>
                  </div>
                  {aiSuggestion.reason && <p className="text-cyan-400/60 text-xs">{aiSuggestion.reason}</p>}
                </div>
              )}

              <div className="mb-4">
                <label className="text-slate-400 text-sm mb-2 block">Category</label>
                <button onClick={() => setShowCategories(true)} className="w-full bg-slate-900 rounded-xl px-4 py-3 text-left flex items-center gap-3">
                  {selectedCat ? (<><span className="text-xl">{selectedCat.icon}</span><span className="text-white">{getCategoryName(selectedCat)}</span></>) : (<span className="text-slate-600">Select category (optional)</span>)}
                </button>
              </div>

              {showCategories && (
                <div className="fixed inset-0 z-50 flex items-center justify-center p-4" onClick={() => setShowCategories(false)}>
                  <div className="absolute inset-0 bg-slate-950/80 backdrop-blur-sm fade-in" />
                  <div className="relative bg-slate-900 w-full max-w-sm rounded-2xl p-5 border border-slate-700 shadow-2xl slide-in" onClick={(e) => e.stopPropagation()}>
                    <div className="flex justify-between items-center mb-4">
                      <h2 className="text-lg font-bold text-white">Select Category</h2>
                      <button onClick={() => setShowCategories(false)} className="w-8 h-8 rounded-full bg-slate-800 flex items-center justify-center text-slate-400">√ó</button>
                    </div>
                    <div className="grid grid-cols-2 gap-2">
                      {GIFT_CATEGORIES.map(cat => (<button key={cat.id} onClick={() => { setCategory(cat.id); setShowCategories(false); }} className={`p-4 rounded-xl flex flex-col items-center gap-2 ${category === cat.id ? 'ring-2 ring-cyan-400' : ''}`} style={{ backgroundColor: cat.color + '20' }}><span className="text-2xl">{cat.icon}</span><span className="text-xs text-white text-center">{getCategoryName(cat)}</span></button>))}
                    </div>
                    {category && <button onClick={() => { setCategory(''); setShowCategories(false); }} className="w-full mt-4 py-2 bg-slate-800 rounded-xl text-slate-400 text-sm">Clear selection</button>}
                  </div>
                </div>
              )}

              <div className="mb-4">
                <label className="text-slate-400 text-sm mb-2 block">Method</label>
                <div className="grid grid-cols-2 gap-2">
                  <button onClick={() => setMethod('cash')} className={`py-3 rounded-xl font-medium ${method === 'cash' ? 'bg-green-600 text-white' : 'bg-slate-900 text-slate-400'}`}>üíµ Cash</button>
                  <button onClick={() => setMethod('bank')} className={`py-3 rounded-xl font-medium ${method === 'bank' ? 'bg-blue-600 text-white' : 'bg-slate-900 text-slate-400'}`}>üè¶ Bank</button>
                </div>
              </div>
              <div className="mb-4">
                <label className="text-slate-400 text-sm mb-2 block">Date</label>
                <input type="date" value={date} onChange={(e) => setDate(e.target.value)} className="w-full bg-slate-900 rounded-xl px-4 py-3 text-white" />
              </div>
              <div className="mb-6">
                <label className="text-slate-400 text-sm mb-2 block">Note</label>
                <input type="text" value={note} onChange={(e) => setNote(e.target.value)} placeholder="(optional)" className="w-full bg-slate-900 rounded-xl px-4 py-3 text-white placeholder-slate-600" />
              </div>
              <button onClick={handleSubmit} disabled={!amount || !donor.trim()} className="w-full py-4 bg-gradient-to-r from-green-600 to-emerald-600 rounded-xl font-bold text-lg disabled:opacity-50">{editing ? "Save" : "Add"}</button>
              {editing && <button onClick={handleDelete} className={`w-full py-3 mt-3 rounded-xl font-medium ${confirmDelete ? 'bg-red-600 text-white' : 'bg-slate-900 text-red-400'}`}>{confirmDelete ? 'Tap again to confirm' : 'Delete'}</button>}
            </div>
            <Nav />
          </div>
        );
      };

      // Add Expense Screen - FIXED but keeping original UI flow
      // Photo required first, iOS picker (camera/photos/files)
      const AddExpense = ({ editing = false }) => {
        const [amount, setAmount] = useState(editing && editingItem ? editingItem.amount.toString() : '');
        const [category, setCategory] = useState(editing && editingItem ? editingItem.category : '');
        const [description, setDescription] = useState(editing && editingItem ? editingItem.description || '' : '');
        const [method, setMethod] = useState(editing && editingItem ? editingItem.method : 'cash');
        const [date, setDate] = useState(editing && editingItem ? editingItem.date : new Date().toISOString().split('T')[0]);
        const [showCategories, setShowCategories] = useState(false);
        const [confirmDelete, setConfirmDelete] = useState(false);
        // FIX: Initialize scanning state from sessionStorage to persist across remounts
        const [scanningLocal, setScanningLocal] = useState(() => sessionStorage.getItem('koha_scanning') === 'true');
        const [scanProgress, setScanProgress] = useState(() => parseInt(sessionStorage.getItem('koha_scan_progress') || '0'));
        const [lastScanInfo, setLastScanInfo] = useState(null);
        const [pendingReceipt, setPendingReceipt] = useState(null);
        const [showReceipt, setShowReceipt] = useState(false);
        const [photoTaken, setPhotoTaken] = useState(editing ? true : false);
        const [scanStatus, setScanStatus] = useState(() => sessionStorage.getItem('koha_scan_status') || '');
        const [debugLog, setDebugLog] = useState(() => localStorage.getItem('scan_debug_log') || '');
        const [showDebugLog, setShowDebugLog] = useState(false);
        const [showReceiptDetails, setShowReceiptDetails] = useState(false);
        
        // Receipt detail fields
        const [subtotal, setSubtotal] = useState(editing && editingItem?.subtotal ? editingItem.subtotal.toString() : '');
        const [gst, setGst] = useState(editing && editingItem?.gst ? editingItem.gst.toString() : '');
        const [discount, setDiscount] = useState(editing && editingItem?.discount ? editingItem.discount.toString() : '');
        const [cashOut, setCashOut] = useState(editing && editingItem?.cashOut ? editingItem.cashOut.toString() : '');
        const [change, setChange] = useState(editing && editingItem?.change ? editingItem.change.toString() : '');
        const [paymentMethod, setPaymentMethod] = useState(editing && editingItem?.paymentMethod || '');
        const [cardLastFour, setCardLastFour] = useState(editing && editingItem?.cardLastFour || '');
        
        const fileInputRef = useRef(null);
        
        const log = (msg) => {
          const timestamp = new Date().toLocaleTimeString();
          const entry = '[' + timestamp + '] ' + msg;
          console.log('[SCAN] ' + msg);
          setDebugLog(prev => { const newLog = prev + '\n' + entry; localStorage.setItem('scan_debug_log', newLog); return newLog; });
        };
        const clearLog = () => { localStorage.removeItem('scan_debug_log'); setDebugLog(''); };
        
        // FIX: Use sessionStorage (not ref) to track recovery across component remounts
        // Refs reset on remount, but sessionStorage persists
        const getRecoveryFlag = () => sessionStorage.getItem('koha_has_recovered') === 'true';
        const setRecoveryFlag = () => sessionStorage.setItem('koha_has_recovered', 'true');
        const clearRecoveryFlag = () => sessionStorage.removeItem('koha_has_recovered');
        
        // FIX #3: Recovery on mount using ScanSession
        // ALWAYS load data from storage, but skip setState if data is already loaded
        useEffect(() => {
          log('AddExpense mounted, editing=' + editing);
          if (editing) return;
          
          const alreadyRecovered = getRecoveryFlag();
          const session = ScanSession.get();
          
          if (session && session.image) {
            // Check if we already have this exact data loaded (prevents redundant setState calls)
            const lastLoadedId = sessionStorage.getItem('koha_last_loaded_session');
            const sessionId = session.savedAt?.toString() || 'unknown';
            
            if (alreadyRecovered && lastLoadedId === sessionId) {
              // Data already loaded from this exact session - skip all setState calls
              log('Skipping setState - data already loaded from session ' + sessionId);
              return;
            }
            
            // Mark this session as loaded
            sessionStorage.setItem('koha_last_loaded_session', sessionId);
            
            if (alreadyRecovered) {
              log('Reloading data from ScanSession (session changed)');
            } else {
              log('Recovering from ScanSession, age=' + Math.round((Date.now() - session.savedAt) / 1000) + 's');
              setRecoveryFlag();
            }
            
            setPendingReceipt({
              originalImage: session.image,
              vendor: session.vendor || '',
              total: session.total || 0,
              items: session.items || [],
              rawText: session.rawText || '',
              subtotal: session.subtotal,
              gst: session.gst,
              paymentMethod: session.paymentMethod
            });
            setPhotoTaken(true);
            
            // Fill form if we have data
            if (session.total) setAmount(session.total.toString());
            if (session.vendor) setDescription(session.vendor);
            if (session.category) setCategory(session.category);
            if (session.date) setDate(session.date);
            if (session.subtotal) setSubtotal(session.subtotal.toString());
            if (session.gst) setGst(session.gst.toString());
            if (session.paymentMethod) {
              setPaymentMethod(session.paymentMethod);
              setMethod(session.paymentMethod === 'Cash' ? 'cash' : 'bank');
            }
            
            // Only show message on first recovery
            if (!alreadyRecovered) {
              if (session.total) {
                setLastScanInfo({ success: true, message: 'Recovered! Review and save.' });
              } else {
                setLastScanInfo({ success: true, message: 'Photo recovered! Tap "Autofill with AI" to scan.' });
              }
            }
            
            if (session.subtotal || session.gst || session.paymentMethod) setShowReceiptDetails(true);
            return;
          }
          
          // Fallback: check old keys (only if not already recovered)
          if (!alreadyRecovered) {
            const pendingResult = localStorage.getItem('pending_scan_result') || sessionStorage.getItem('pending_scan_result');
            if (pendingResult) {
              try {
                const result = JSON.parse(pendingResult);
                if (Date.now() - (result.savedAt || 0) < 60000) {
                  setRecoveryFlag(); // Mark as recovered
                  log('Recovering from old pending_scan_result');
                  if (result.total) setAmount(result.total.toString());
                  if (result.vendor) setDescription(result.vendor);
                  if (result.category) setCategory(result.category);
                  if (result.originalImage) {
                    setPendingReceipt({ originalImage: result.originalImage, ...result });
                    setPhotoTaken(true);
                  }
                  setLastScanInfo({ success: true, message: 'Recovered! Review and save.' });
                }
              } catch (e) { log('Error parsing old result: ' + e.message); }
              // Clear old keys
              localStorage.removeItem('pending_scan_result');
              sessionStorage.removeItem('pending_scan_result');
            }
          }
        }, [editing]);

        // FIX #4: Save state when page backgrounds (iOS memory pressure protection)
        useEffect(() => {
          const handleVisibility = () => {
            if (document.visibilityState === 'hidden' && pendingReceipt?.originalImage) {
              log('Page hidden - saving scan session');
              ScanSession.save({
                image: pendingReceipt.originalImage,
                vendor: description || pendingReceipt.vendor,
                total: parseFloat(amount) || pendingReceipt.total,
                category: category,
                date: date,
                items: pendingReceipt.items,
                rawText: pendingReceipt.rawText,
                subtotal: subtotal ? parseFloat(subtotal) : pendingReceipt.subtotal,
                gst: gst ? parseFloat(gst) : pendingReceipt.gst,
                paymentMethod: paymentMethod || pendingReceipt.paymentMethod
              });
            }
          };
          document.addEventListener('visibilitychange', handleVisibility);
          return () => document.removeEventListener('visibilitychange', handleVisibility);
        }, [pendingReceipt, amount, description, category, date, subtotal, gst, paymentMethod]);

        // FIX: Persist scanning state to sessionStorage so overlay survives remounts
        useEffect(() => {
          sessionStorage.setItem('koha_scanning', scanningLocal ? 'true' : 'false');
          sessionStorage.setItem('koha_scan_progress', scanProgress.toString());
          sessionStorage.setItem('koha_scan_status', scanStatus);
        }, [scanningLocal, scanProgress, scanStatus]);

        // FIX #7: Save breadcrumb BEFORE opening camera - but DON'T destroy existing session data
        const handleOpenCamera = (e) => {
          e.preventDefault();
          log('Opening camera');
          sessionStorage.setItem('return_to_screen', 'addExpense');
          // DON'T call ScanSession.save here - it would overwrite existing scan data!
          // DON'T clear recovery flag here - only clear when we actually get new data
          fileInputRef.current?.click();
        };

        // FIX #5: Handle file with compression, no reload
        const handleScan = async (e) => {
          log('--- SCAN STARTED ---');
          try {
            const file = e.target.files?.[0];
            if (!file) { log('ERROR: No file'); return; }
            
            log('File: ' + file.name + ' (' + Math.round(file.size/1024) + 'KB)');
            setScanningLocal(true);
            setScanProgress(20);
            setScanStatus('Reading photo...');
            
            const reader = new FileReader();
            reader.onload = async () => {
              const base64 = reader.result.split(',')[1];
              log('Read file: ' + Math.round(base64.length/1024) + 'KB');
              
              setScanProgress(40);
              setScanStatus('Compressing...');
              
              // FIX #2: Use improved compression
              const compressed = await compressForStorage(base64, 400);
              log('Compressed to: ' + Math.round(compressed.length/1024) + 'KB');
              
              setScanProgress(60);
              setScanStatus('Saving...');
              
              // Save immediately with ScanSession
              ScanSession.save({ image: compressed, cameraOpenedAt: Date.now() });
              setRecoveryFlag(); // Mark as having data to prevent re-recovery glitches
              
              // Update state directly (no reload!)
              setPendingReceipt({
                originalImage: compressed,
                scannedAt: new Date().toISOString(),
                vendor: '',
                total: 0
              });
              setPhotoTaken(true);
              
              setScanProgress(100);
              setScanStatus('Photo ready!');
              setLastScanInfo({ success: true, message: 'Photo captured! Tap "Autofill with AI" to scan.' });
              
              setScanningLocal(false);
              setTimeout(() => { setScanProgress(0); setScanStatus(''); }, 1000);
              log('Photo saved to state, ready for AI scan');
            };
            
            reader.onerror = () => {
              log('FileReader error');
              setScanningLocal(false);
            };
            
            reader.readAsDataURL(file);
          } catch (error) {
            log('ERROR: ' + error.message);
            setScanningLocal(false);
          }
        };
        
        // Manual AI scan - uses fixed scanReceipt (no reload)
        const runAIScan = async () => {
          log('--- AI SCAN STARTED ---');
          if (!pendingReceipt?.originalImage) { log('ERROR: No image'); return; }
          
          log('Image size: ' + Math.round(pendingReceipt.originalImage.length / 1024) + 'KB');
          setScanningLocal(true);
          setScanProgress(0);
          setScanStatus('Initializing...');
          
          try {
            const result = await scanReceipt(pendingReceipt.originalImage, (progress) => {
              setScanProgress(progress);
              if (progress < 30) setScanStatus('Reading text...');
              else if (progress < 70) setScanStatus('Processing...');
              else setScanStatus('Analyzing...');
            });
            
            setScanProgress(100);
            setScanStatus('Complete!');
            
            if (result && result.total) {
              log('SUCCESS: total=' + result.total + ', vendor=' + result.vendor);
              setAmount(result.total.toString());
              if (result.date) setDate(result.date);
              if (result.category) setCategory(result.category);
              if (result.vendor) setDescription(result.vendor);
              if (result.subtotal) setSubtotal(result.subtotal.toString());
              if (result.gst) setGst(result.gst.toString());
              if (result.paymentMethod) {
                setPaymentMethod(result.paymentMethod);
                setMethod(['Cash'].includes(result.paymentMethod) ? 'cash' : 'bank');
              }
              if (result.subtotal || result.gst || result.paymentMethod) setShowReceiptDetails(true);
              
              setPendingReceipt(prev => ({ ...prev, ...result }));
              setLastScanInfo({ vendor: result.vendor, total: result.total, success: true });
            } else {
              log('WARN: No total in result');
              setLastScanInfo({ error: true, message: 'Could not read receipt. Enter details manually.' });
            }
          } catch (err) {
            log('ERROR: ' + err.message);
            setLastScanInfo({ error: true, message: 'Scan failed: ' + err.message });
          }
          
          setScanningLocal(false);
          setTimeout(() => { setScanProgress(0); setScanStatus(''); }, 1000);
          setTimeout(() => setLastScanInfo(null), 8000);
        };
        
        const currentReceipt = pendingReceipt || (editing && editingItem?.receipt) || null;

        // Receipt Viewer Component
        const ReceiptViewer = ({ receipt, onClose }) => {
          const [viewOriginal, setViewOriginal] = useState(false);
          if (!receipt) return null;
          return (
            <div className="fixed inset-0 z-50 flex items-center justify-center p-4" onClick={onClose}>
              <div className="absolute inset-0 bg-slate-950/80 backdrop-blur-sm fade-in" />
              <div className="relative bg-slate-900 w-full max-w-md rounded-2xl max-h-[85vh] overflow-auto border border-slate-700 shadow-2xl slide-in" onClick={(e) => e.stopPropagation()}>
                <div className="sticky top-0 bg-slate-900 border-b border-slate-800 p-4 flex justify-between items-center z-10">
                  <h2 className="text-lg font-bold text-white">üßæ Receipt</h2>
                  <div className="flex gap-2">
                    {receipt.originalImage && <button onClick={() => setViewOriginal(!viewOriginal)} className={`px-3 py-1 rounded-lg text-xs font-medium ${viewOriginal ? 'bg-purple-600 text-white' : 'bg-slate-800 text-slate-400'}`}>{viewOriginal ? 'üìù Text' : 'üì∑ Photo'}</button>}
                    <button onClick={onClose} className="w-8 h-8 rounded-full bg-slate-800 flex items-center justify-center text-slate-400">√ó</button>
                  </div>
                </div>
                {viewOriginal && receipt.originalImage ? (
                  <div className="p-4"><img src={`data:image/jpeg;base64,${receipt.originalImage}`} alt="Receipt" className="w-full rounded-xl" /></div>
                ) : (
                  <div className="p-4">
                    <div className="text-center mb-4 pb-4 border-b border-slate-800">
                      <p className="text-xl font-bold text-white">{receipt.vendor || 'Unknown Store'}</p>
                      {(receipt.date || receipt.time) && <p className="text-slate-400 text-sm mt-2">{receipt.date && fmtDateFull(receipt.date)}{receipt.time && ` at ${receipt.time}`}</p>}
                    </div>
                    {Array.isArray(receipt.items) && receipt.items.length > 0 && (
                      <div className="mb-4">
                        <p className="text-slate-500 text-xs font-medium mb-2">ITEMS</p>
                        <div className="space-y-2">{receipt.items.map((item, i) => (<div key={i} className="flex justify-between text-sm"><span className="text-white">{item.name}</span>{item.price && <span className="text-slate-300">{fmt(item.price)}</span>}</div>))}</div>
                      </div>
                    )}
                    <div className="border-t border-slate-800 pt-4 space-y-2">
                      {receipt.subtotal && <div className="flex justify-between text-sm"><span className="text-slate-400">Subtotal</span><span className="text-slate-300">{fmt(receipt.subtotal)}</span></div>}
                      {receipt.gst && <div className="flex justify-between text-sm"><span className="text-slate-400">GST (15%)</span><span className="text-slate-300">{fmt(receipt.gst)}</span></div>}
                      {receipt.total && <div className="flex justify-between text-lg font-bold pt-2 border-t border-slate-700"><span className="text-white">TOTAL</span><span className="text-white">{fmt(receipt.total)}</span></div>}
                      {receipt.paymentMethod && <div className="flex justify-between text-sm pt-2"><span className="text-slate-500">Paid by</span><span className="text-slate-400">{receipt.paymentMethod}</span></div>}
                    </div>
                  </div>
                )}
              </div>
            </div>
          );
        };

        // FIX #8: Clear session on submit/back
        const handleSubmit = () => {
          if (!amount || !category) return;
          const expenseData = { 
            amount: parseFloat(amount), category, description: description.trim(), method, date,
            receipt: pendingReceipt || (editing && editingItem?.receipt) || null,
            ...(subtotal && { subtotal: parseFloat(subtotal) }),
            ...(gst && { gst: parseFloat(gst) }),
            ...(paymentMethod && { paymentMethod })
          };
          if (editing && editingItem) updateExpense(editingItem.id, expenseData);
          else addExpense(expenseData);
          ScanSession.clear();
          clearRecoveryFlag();
          sessionStorage.removeItem('koha_last_loaded_session');
          sessionStorage.removeItem('koha_scanning');
          setScreen('expenses');
          setEditingItem(null);
        };

        const handleDelete = () => {
          if (confirmDelete) { 
            deleteExpense(editingItem.id); 
            ScanSession.clear(); 
            clearRecoveryFlag(); 
            sessionStorage.removeItem('koha_last_loaded_session');
            setScreen('expenses'); 
            setEditingItem(null); 
          }
          else { setConfirmDelete(true); setTimeout(() => setConfirmDelete(false), 3000); }
        };

        const handleBack = () => {
          ScanSession.clear();
          clearRecoveryFlag();
          sessionStorage.removeItem('koha_last_loaded_session');
          sessionStorage.removeItem('koha_scanning');
          setScreen(editing ? 'expenses' : 'home');
          setEditingItem(null);
        };

        const groupedCategories = useMemo(() => ({
          tangihanga: EXPENSE_CATEGORIES.filter(c => c.group === 'tangihanga'),
          kai: EXPENSE_CATEGORIES.filter(c => c.group === 'kai'),
          travel: EXPENSE_CATEGORIES.filter(c => c.group === 'travel'),
          utilities: EXPENSE_CATEGORIES.filter(c => c.group === 'utilities'),
          other: EXPENSE_CATEGORIES.filter(c => c.group === 'other')
        }), []);

        return (
          <div className="min-h-screen bg-slate-950 text-white pb-24">
            {/* Full-screen scanning overlay - much more visible! */}
            <ScanningOverlay visible={scanningLocal} progress={scanProgress} status={scanStatus} />
            
            <div className="px-5 pt-8">
              <button onClick={handleBack} className="text-slate-500 text-sm mb-4">‚Üê Back</button>
              
              {/* ORIGINAL UI: Photo required first for new expenses */}
              {!editing && !photoTaken ? (
                <div className="min-h-[70vh] flex flex-col items-center justify-center px-6">
                  {/* Single file input - NO capture attribute so iOS shows picker menu */}
                  <input ref={fileInputRef} type="file" accept="image/*" onChange={handleScan} className="hidden" key="camera-input" />
                  
                  {scanningLocal ? (
                    /* When scanning, show nothing here as the full-screen overlay handles it */
                    null
                  ) : (
                    <>
                      <div className="w-24 h-24 mb-6 rounded-2xl bg-purple-500/20 flex items-center justify-center"><span className="text-5xl">üßæ</span></div>
                      <h1 className="text-2xl font-bold text-white mb-2">Add Receipt</h1>
                      <p className="text-slate-400 text-center mb-8">Snap a photo and AI will read it</p>
                      
                      <div className="w-full max-w-xs space-y-3">
                        {/* FIX #7: Save breadcrumb BEFORE opening camera */}
                        <button type="button" onClick={handleOpenCamera} className="w-full py-4 bg-gradient-to-r from-purple-600 to-pink-600 rounded-2xl text-lg font-bold flex items-center justify-center gap-3">üì∑ Add Photo</button>
                        <p className="text-slate-500 text-xs text-center">You'll be able to take a new photo or choose from your library</p>
                      </div>
                      
                      {/* Debug button */}
                      <button onClick={(e) => { e.preventDefault(); setDebugLog(localStorage.getItem('scan_debug_log') || ''); setShowDebugLog(true); }} className="fixed bottom-24 right-4 w-12 h-12 bg-slate-800 rounded-full flex items-center justify-center text-xl border border-slate-700 z-50">üêõ</button>
                      
                      {showDebugLog && (
                        <div className="fixed inset-0 z-50 flex items-center justify-center p-4" onClick={() => setShowDebugLog(false)}>
                          <div className="absolute inset-0 bg-slate-950/90" />
                          <div className="relative bg-slate-900 w-full max-w-md rounded-2xl p-4 border border-slate-700" onClick={(e) => e.stopPropagation()}>
                            <div className="flex justify-between items-center mb-3"><h3 className="text-white font-bold">üêõ Debug Log</h3><button onClick={() => setShowDebugLog(false)} className="text-slate-400 text-xl">√ó</button></div>
                            <textarea readOnly value={debugLog || '(empty)'} className="w-full bg-slate-800 rounded-xl px-3 py-2 text-xs text-green-400 font-mono h-48" onClick={(e) => e.target.select()} />
                            <div className="flex gap-2 mt-3">
                              <button onClick={async (e) => { e.preventDefault(); await copyToClipboard(debugLog); }} className="flex-1 py-2 bg-cyan-600 rounded-lg text-sm font-medium">üìã Copy</button>
                              <button onClick={(e) => { e.preventDefault(); clearLog(); }} className="flex-1 py-2 bg-slate-700 rounded-lg text-sm">üóëÔ∏è Clear</button>
                            </div>
                          </div>
                        </div>
                      )}
                    </>
                  )}
                </div>
              ) : (
                <>
                  {/* Normal form after photo taken or when editing */}
                  <div className="flex justify-between items-center mb-6">
                    <h1 className="text-2xl font-bold">{editing ? "Edit" : "Add Expense"}</h1>
                    {!editing && (
                      <>
                        <input ref={fileInputRef} type="file" accept="image/*" onChange={handleScan} className="hidden" />
                        <button onClick={() => fileInputRef.current?.click()} disabled={scanningLocal || scanning} className="flex items-center gap-2 px-4 py-2 bg-purple-600 rounded-xl text-sm font-medium disabled:opacity-50">
                          {scanningLocal || scanning ? <><span className="spin">üîÑ</span> Scanning...</> : <>üì∑ Rescan</>}
                        </button>
                      </>
                    )}
                  </div>

                  {lastScanInfo && (
                    <div className={`${lastScanInfo.error ? 'bg-orange-900/30 border-orange-700/50' : 'bg-green-900/30 border-green-700/50'} border rounded-xl p-3 mb-4 slide-in`}>
                      <div className="flex items-center gap-2">
                        <span className={lastScanInfo.error ? 'text-orange-400' : 'text-green-400'}>{lastScanInfo.error ? '‚ö†Ô∏è' : '‚úì'}</span>
                        <span className={`${lastScanInfo.error ? 'text-orange-200' : 'text-green-200'} text-sm`}>
                          {lastScanInfo.error ? lastScanInfo.message : `Detected: ${lastScanInfo.vendor || 'Receipt'}${lastScanInfo.total ? ` - $${lastScanInfo.total}` : ''}`}
                        </span>
                      </div>
                    </div>
                  )}

                  {currentReceipt && (
                    <div className="mb-4">
                      <button onClick={() => setShowReceipt(true)} className="w-full bg-purple-900/30 border border-purple-700/50 rounded-xl p-3 flex items-center justify-between active:bg-purple-900/50">
                        <div className="flex items-center gap-3">
                          <span className="text-2xl">üßæ</span>
                          <div className="text-left">
                            <p className="text-purple-200 font-medium">{currentReceipt.vendor || 'Photo attached'}</p>
                            <p className="text-purple-400 text-xs">{currentReceipt.total ? `$${currentReceipt.total}` : 'Tap to view'}{Array.isArray(currentReceipt.items) && currentReceipt.items.length > 0 && ` ‚Ä¢ ${currentReceipt.items.length} items`}</p>
                          </div>
                        </div>
                        <span className="text-purple-400">View ‚Üí</span>
                      </button>
                      
                      {!currentReceipt.total && !scanningLocal && (
                        <button onClick={runAIScan} className="w-full mt-3 py-4 bg-gradient-to-r from-cyan-600 to-blue-600 rounded-xl font-medium">
                          <div className="flex items-center justify-center gap-3"><span className="text-lg">‚ú®</span><span>Autofill with AI</span></div>
                          <p className="text-cyan-200/60 text-xs mt-1">Powered by Google Cloud Vision</p>
                        </button>
                      )}
                      
                      {scanningLocal && (
                        <div className="w-full mt-3 bg-slate-800/80 rounded-xl p-4 border border-slate-700">
                          <div className="flex items-center justify-between mb-2">
                            <span className="text-white font-medium flex items-center gap-2">
                              <span className="relative flex h-2 w-2"><span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-cyan-400 opacity-75"></span><span className="relative inline-flex rounded-full h-2 w-2 bg-cyan-500"></span></span>
                              {scanStatus || 'Processing...'}
                            </span>
                            <span className="text-cyan-400 font-bold">{scanProgress}%</span>
                          </div>
                          <div className="h-2 bg-slate-900 rounded-full overflow-hidden">
                            <div className="h-full bg-gradient-to-r from-cyan-500 to-blue-500 rounded-full transition-all duration-300 ease-out" style={{ width: `${scanProgress}%` }} />
                          </div>
                        </div>
                      )}
                    </div>
                  )}

                  {showReceipt && currentReceipt && <ReceiptViewer receipt={currentReceipt} onClose={() => setShowReceipt(false)} />}

                  <div className="mb-4">
                    <label className="text-slate-400 text-sm mb-2 block">Amount</label>
                    <div className="relative">
                      <span className="absolute left-4 top-1/2 -translate-y-1/2 text-slate-400 text-xl">$</span>
                      <input type="number" value={amount} onChange={(e) => setAmount(e.target.value)} placeholder="0.00" className="w-full bg-slate-900 rounded-xl px-4 py-4 pl-10 text-2xl font-bold text-white placeholder-slate-600 outline-none" />
                    </div>
                  </div>

                  <div className="mb-4">
                    <div className="flex justify-between items-center mb-2">
                      <label className="text-slate-400 text-sm">Category</label>
                      <CatLangSelector showLabel={false} />
                    </div>
                    <button onClick={() => setShowCategories(true)} className="w-full bg-slate-900 rounded-xl px-4 py-3 text-left flex items-center gap-3">
                      {category ? (<><span className="text-xl">{getCategoryById(category).icon}</span><span className="text-white">{getCategoryName(getCategoryById(category))}</span></>) : (<span className="text-slate-600">Select</span>)}
                    </button>
                  </div>

                  {showCategories && (
                    <div className="fixed inset-0 bg-black/80 z-50 flex items-end">
                      <div className="bg-slate-900 w-full rounded-t-3xl p-5 pb-10 max-h-[80vh] overflow-auto">
                        <div className="flex justify-between items-center mb-4">
                          <h2 className="text-lg font-bold text-white">Select Category</h2>
                          <div className="flex items-center gap-2"><CatLangSelector /><button onClick={() => setShowCategories(false)} className="text-slate-400 text-2xl ml-2">√ó</button></div>
                        </div>
                        {Object.entries({ tangihanga: 'FUNERAL', kai: 'FOOD', travel: 'TRAVEL', utilities: 'OTHER', other: '' }).map(([group, label]) => {
                          const cats = group === 'utilities' ? [...groupedCategories.utilities, ...groupedCategories.other] : groupedCategories[group];
                          if (!cats?.length || group === 'other') return null;
                          return (
                            <div key={group}>
                              <p className="text-slate-500 text-xs font-medium mb-2 mt-4">{label}</p>
                              <div className="grid grid-cols-3 gap-2 mb-4">
                                {cats.map(cat => (<button key={cat.id} onClick={() => { setCategory(cat.id); setShowCategories(false); }} className={`p-3 rounded-xl flex flex-col items-center gap-1 ${category === cat.id ? 'bg-cyan-600' : 'bg-slate-800 active:bg-slate-700'}`}><span className="text-xl">{cat.icon}</span><span className="text-xs text-white text-center leading-tight">{getCategoryName(cat)}</span></button>))}
                              </div>
                            </div>
                          );
                        })}
                      </div>
                    </div>
                  )}

                  <div className="mb-4">
                    <label className="text-slate-400 text-sm mb-2 block">Description (helps AI categorize)</label>
                    <input type="text" value={description} onChange={(e) => setDescription(e.target.value)} placeholder="e.g. Countdown, Z Station, etc" className="w-full bg-slate-900 rounded-xl px-4 py-3 text-white placeholder-slate-600 outline-none" />
                  </div>

                  <div className="mb-4">
                    <label className="text-slate-400 text-sm mb-2 block">Paid with</label>
                    <div className="grid grid-cols-2 gap-2">
                      <button onClick={() => setMethod('cash')} className={`py-3 rounded-xl font-medium ${method === 'cash' ? 'bg-green-600 text-white' : 'bg-slate-900 text-slate-400'}`}>üíµ Cash</button>
                      <button onClick={() => setMethod('bank')} className={`py-3 rounded-xl font-medium ${method === 'bank' ? 'bg-blue-600 text-white' : 'bg-slate-900 text-slate-400'}`}>üè¶ Bank</button>
                    </div>
                  </div>

                  <div className="mb-6">
                    <label className="text-slate-400 text-sm mb-2 block">Date</label>
                    <input type="date" value={date} onChange={(e) => setDate(e.target.value)} className="w-full bg-slate-900 rounded-xl px-4 py-3 text-white" />
                  </div>
                  
                  <button onClick={handleSubmit} disabled={!amount || !category} className="w-full py-4 bg-gradient-to-r from-orange-600 to-red-600 rounded-xl font-bold text-lg disabled:opacity-50">{editing ? "Save" : "Add"}</button>
                  {editing && <button onClick={handleDelete} className={`w-full py-3 mt-3 rounded-xl font-medium ${confirmDelete ? 'bg-red-600 text-white' : 'bg-slate-900 text-red-400'}`}>{confirmDelete ? 'Tap again to confirm' : 'Delete'}</button>}
                  
                  <button onClick={(e) => { e.preventDefault(); setDebugLog(localStorage.getItem('scan_debug_log') || ''); setShowDebugLog(true); }} className="w-full py-2 mt-4 bg-slate-800 rounded-xl text-slate-500 text-sm flex items-center justify-center gap-2">üêõ Debug Log</button>
                  
                  {showDebugLog && (
                    <div className="fixed inset-0 z-50 flex items-center justify-center p-4" onClick={() => setShowDebugLog(false)}>
                      <div className="absolute inset-0 bg-slate-950/90" />
                      <div className="relative bg-slate-900 w-full max-w-md rounded-2xl p-4 border border-slate-700" onClick={(e) => e.stopPropagation()}>
                        <div className="flex justify-between items-center mb-3"><h3 className="text-white font-bold">üêõ Debug Log</h3><button onClick={() => setShowDebugLog(false)} className="text-slate-400 text-xl">√ó</button></div>
                        <textarea readOnly value={debugLog || '(empty)'} className="w-full bg-slate-800 rounded-xl px-3 py-2 text-xs text-green-400 font-mono h-64" onClick={(e) => e.target.select()} />
                        <div className="flex gap-2 mt-3">
                          <button onClick={async (e) => { e.preventDefault(); await copyToClipboard(debugLog); }} className="flex-1 py-2 bg-cyan-600 rounded-lg text-sm font-medium">üìã Copy</button>
                          <button onClick={(e) => { e.preventDefault(); clearLog(); }} className="flex-1 py-2 bg-slate-700 rounded-lg text-sm">üóëÔ∏è Clear</button>
                        </div>
                      </div>
                    </div>
                  )}
                </>
              )}
            </div>
            <Nav />
          </div>
        );
      };

      // Gifts List
      const Gifts = () => {
        const [filter, setFilter] = useState('all');
        const [search, setSearch] = useState('');
        const [catFilter, setCatFilter] = useState('all');
        
        const filteredGifts = useMemo(() => {
          let result = [...gifts];
          if (filter === 'cash' || filter === 'bank') result = result.filter(g => g.method === filter);
          if (catFilter !== 'all') result = result.filter(g => g.category === catFilter);
          if (search.trim()) result = result.filter(g => g.donor.toLowerCase().includes(search.toLowerCase()));
          return result.sort((a, b) => new Date(b.date) - new Date(a.date));
        }, [gifts, filter, catFilter, search]);

        const categoryCounts = useMemo(() => {
          const counts = {};
          gifts.forEach(g => { const cat = g.category || 'isi'; counts[cat] = (counts[cat] || 0) + 1; });
          return counts;
        }, [gifts]);

        return (
          <div className="min-h-screen bg-slate-950 text-white pb-24">
            <div className="px-5 pt-8">
              <div className="flex justify-between items-start mb-4">
                <div>
                  <h1 className="text-2xl font-bold">Meaalofa ‚Ä¢ Koha</h1>
                  <p className="text-slate-500 text-sm">{gifts.length} total: {fmt(totals.giftsTotal)}</p>
                </div>
                <button onClick={() => setScreen('addGift')} className="w-10 h-10 bg-green-600 rounded-full flex items-center justify-center text-xl">+</button>
              </div>
              <input type="text" value={search} onChange={(e) => setSearch(e.target.value)} placeholder="Search..." className="w-full bg-slate-900 rounded-xl px-4 py-3 text-white placeholder-slate-600 outline-none mb-4" />
              
              <div className="flex gap-2 mb-3">
                {[{ id: 'all', label: 'All' }, { id: 'cash', label: 'üíµ' }, { id: 'bank', label: 'üè¶' }].map(f => (
                  <button key={f.id} onClick={() => setFilter(f.id)} className={`px-4 py-2 rounded-lg text-sm font-medium ${filter === f.id ? 'bg-cyan-600 text-white' : 'bg-slate-900 text-slate-400'}`}>{f.label}</button>
                ))}
              </div>

              <div className="flex gap-2 mb-4 overflow-x-auto pb-2">
                <button onClick={() => setCatFilter('all')} className={`px-3 py-1.5 rounded-lg text-sm font-medium whitespace-nowrap ${catFilter === 'all' ? 'bg-green-600 text-white' : 'bg-slate-900 text-slate-400'}`}>All</button>
                {GIFT_CATEGORIES.map(cat => (
                  <button key={cat.id} onClick={() => setCatFilter(cat.id)} className={`px-3 py-1.5 rounded-lg text-sm font-medium whitespace-nowrap flex items-center gap-1 ${catFilter === cat.id ? 'text-white' : 'bg-slate-900 text-slate-400'}`} style={catFilter === cat.id ? { backgroundColor: cat.color } : {}}>{cat.icon} {categoryCounts[cat.id] || 0}</button>
                ))}
              </div>

              <div className="space-y-2">
                {filteredGifts.map(g => {
                  const cat = getGiftCategoryById(g.category);
                  return (
                    <div key={g.id} onClick={() => { setEditingItem(g); setScreen('editGift'); }} className="bg-slate-900 rounded-xl p-4 active:bg-slate-800">
                      <div className="flex items-start gap-3">
                        <div className="w-10 h-10 rounded-full flex items-center justify-center text-lg" style={{ backgroundColor: cat.color + '30' }}>{cat.icon}</div>
                        <div className="flex-1">
                          <p className="font-medium text-white">{g.donor}</p>
                          <p className="text-slate-500 text-sm">{fmtDateFull(g.date)} ‚Ä¢ {g.method === 'cash' ? 'üíµ' : 'üè¶'}{g.category && g.category !== 'isi' && <span className="ml-1" style={{ color: cat.color }}>‚Ä¢ {cat.en}</span>}</p>
                        </div>
                        <p className="text-green-400 font-bold text-lg">{fmt(g.amount)}</p>
                      </div>
                    </div>
                  );
                })}
              </div>
              {filteredGifts.length === 0 && <div className="text-center py-12"><span className="text-4xl mb-4 block">üéÅ</span><p className="text-slate-400">No gifts yet</p></div>}
            </div>
            <Nav />
          </div>
        );
      };

      // Expenses List
      const Expenses = () => {
        const [filter, setFilter] = useState('all');
        const [search, setSearch] = useState('');
        const [showTransfers, setShowTransfers] = useState(false);
        
        const filteredExpenses = useMemo(() => {
          let result = [...expenses];
          if (filter === 'cash' || filter === 'bank') result = result.filter(e => e.method === filter);
          if (filter === 'receipts') result = result.filter(e => !!e.receipt);
          if (search.trim()) result = result.filter(e => e.description?.toLowerCase().includes(search.toLowerCase()) || getCategoryById(e.category).en.toLowerCase().includes(search.toLowerCase()));
          return result.sort((a, b) => new Date(b.date) - new Date(a.date));
        }, [expenses, filter, search]);
        
        const receiptCount = useMemo(() => expenses.filter(e => !!e.receipt).length, [expenses]);

        return (
          <div className="min-h-screen bg-slate-950 text-white pb-24">
            <div className="px-5 pt-8">
              <div className="flex justify-between items-start mb-4">
                <div>
                  <h1 className="text-2xl font-bold">Tau ‚Ä¢ Utu</h1>
                  <p className="text-slate-500 text-sm">{expenses.length} total: {fmt(totals.expensesTotal)}</p>
                </div>
                <div className="flex gap-2">
                  <CatLangSelector showLabel={false} />
                  <button onClick={() => setScreen('addExpense')} className="w-10 h-10 bg-orange-600 rounded-full flex items-center justify-center text-xl">+</button>
                </div>
              </div>
              <input type="text" value={search} onChange={(e) => setSearch(e.target.value)} placeholder="Search..." className="w-full bg-slate-900 rounded-xl px-4 py-3 text-white placeholder-slate-600 outline-none mb-4" />
              <div className="flex gap-2 mb-4 overflow-x-auto pb-2">
                {[{ id: 'all', label: 'All' }, { id: 'cash', label: 'üíµ' }, { id: 'bank', label: 'üè¶' }, { id: 'receipts', label: `üßæ ${receiptCount}` }].map(f => (
                  <button key={f.id} onClick={() => setFilter(f.id)} className={`px-4 py-2 rounded-lg text-sm font-medium whitespace-nowrap ${filter === f.id ? 'bg-cyan-600 text-white' : 'bg-slate-900 text-slate-400'}`}>{f.label}</button>
                ))}
              </div>
              {transfers.length > 0 && (
                <div className="mb-4">
                  <button onClick={() => setShowTransfers(!showTransfers)} className="w-full bg-blue-900/30 border border-blue-700/50 rounded-xl p-3 flex justify-between items-center">
                    <span className="text-blue-400 text-sm">üíµ‚Üíüè¶ Deposits ({transfers.length})</span>
                    <span className="text-blue-400 font-medium">{fmt(totals.transferredToBank)}</span>
                  </button>
                  {showTransfers && (
                    <div className="mt-2 space-y-2">
                      {transfers.sort((a, b) => new Date(b.date) - new Date(a.date)).map(t => (
                        <div key={t.id} className="bg-slate-900 rounded-xl p-3 flex justify-between items-center">
                          <div><p className="text-white text-sm">{fmtDateFull(t.date)}</p>{t.note && <p className="text-slate-500 text-xs">{t.note}</p>}</div>
                          <div className="flex items-center gap-2">
                            <p className="text-blue-400 font-medium">{fmt(t.amount)}</p>
                            <button onClick={() => { if (confirm('Delete?')) deleteTransfer(t.id); }} className="text-red-400 text-xs px-2 py-1 bg-red-900/30 rounded">‚úï</button>
                          </div>
                        </div>
                      ))}
                    </div>
                  )}
                </div>
              )}
              <div className="space-y-2">
                {filteredExpenses.map(e => {
                  const cat = getCategoryById(e.category);
                  const result = validationResults[e.id];
                  const flagged = result && !result.correct && !result.dismissed && !result.applied;
                  const hasReceipt = !!e.receipt;
                  return (
                    <div key={e.id} onClick={() => { setEditingItem(e); setScreen('editExpense'); }} className={`bg-slate-900 rounded-xl p-4 active:bg-slate-800 ${flagged ? 'border border-amber-500/50' : ''}`}>
                      <div className="flex items-start gap-3">
                        <div className="w-10 h-10 bg-slate-800 rounded-full flex items-center justify-center relative">
                          <span>{cat.icon}</span>
                          {hasReceipt && <span className="absolute -bottom-1 -right-1 w-5 h-5 bg-purple-600 rounded-full flex items-center justify-center text-xs">üßæ</span>}
                        </div>
                        <div className="flex-1">
                          <p className="font-medium text-white">{e.description || getCategoryName(cat)}</p>
                          <p className="text-slate-500 text-sm">{fmtDateFull(e.date)} ‚Ä¢ {e.method === 'cash' ? 'üíµ' : 'üè¶'}{hasReceipt && <span className="text-purple-400 ml-1">‚Ä¢ Receipt</span>}</p>
                        </div>
                        <div className="text-right">
                          <p className="text-red-400 font-bold text-lg">{fmt(e.amount)}</p>
                          {flagged && <span className="text-amber-400 text-xs">‚ö†Ô∏è Review</span>}
                        </div>
                      </div>
                    </div>
                  );
                })}
              </div>
              {filteredExpenses.length === 0 && <div className="text-center py-12"><span className="text-4xl mb-4 block">üí∏</span><p className="text-slate-400">No expenses yet</p></div>}
            </div>
            <Nav />
          </div>
        );
      };

      // Route screens
      const screens = {
        home: Home,
        gifts: Gifts,
        expenses: Expenses,
        analytics: Analytics,
        sync: SyncScreen,
        addGift: () => <AddGift editing={false} />,
        addExpense: () => <AddExpense editing={false} />,
        editGift: () => <AddGift editing={true} />,
        editExpense: () => <AddExpense editing={true} />,
        addTransfer: AddTransfer
      };

      const Screen = screens[screen] || Home;
      return <Screen />;
    };

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
